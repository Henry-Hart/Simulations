<!-- modified from url=(0060)https://furryelephant.com/eton/simple-circuit-iframe-v8.html -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
<script>function preload() {}

function create() {
     /*

     Modified by Henry Hart

     Stuff added:

     - a function to help with compatibility
     - touchscreen flexibility

     TODO:

     - reliable compatibility for firefox (sometimes the text is messed up)
     - bug reporting system

     */
     _g.tickDelay = 83 //ms delay to immitate 12 fps

    _g.totalCharges = 50;
    _g.energy = [];
    _g.charge = [];

    _g.refSpeed = 20; //the speed to give 1 charge per second with a delay of 83 ms for the frame rate
    _g.maxSpeed = 100; //before charges look like they're going backwards at delay of 83 ms for the frame rate
    _g.speed = _g.refSpeed; //has to be a whole number, since you're stepping through an array map

    //used to increase the number of items in the map array by more than the number of pixels round the loop
    //Gives better resolution for wide variety of speeds at higher 'frame rate' as you move around array
    _g.mapMult = 10;
    _g.mapLength;

    _g.powerCircleCurrent = 1;

    _g.draggableItems = [];
    _g.draggedObject;
    _g.draggedIndex;
    _g.dragged;
    _g.dragging = false;

    /*
    //offsets for firefox
    _g.mozArray = [-77,-154,-59,-46,-77,-87,-87,-71,-68]
    //[-85,-142,-67,-40,-85,-87,-87,-71,-68]
    const {userAgent} = navigator;
    userAgent.match(/firefox/i) !== null ?
    alert("incompatible browser, text may be messed up!") :
    _g.mozArray = [0,0,0,0,0,0,0,0,0];

    //for development
    if(getCookie("dev") == "1") { for (var i = 0; i < 9; i++) { _g.mozArray[i] = Number(getCookie(i.toString())); } }
    */


    _g.mozArray = [0,0,0,0,0,0,0,0,0];

    /* mozArray:
    0 text above
    1 component output
    2 text below
    3 seconds text on stopwatch
    4 tick box + 'measurement and display' text
    5 voltage slider numbers
    6 voltage slider text
    7 resistance slider text
    8 resistance slider numbers
    */

    _g.voltmeterDisplay = '-.-';

    _g.ammeterOnWire = false;

    _g.showEnergy = true;
    // precision
  	_g.precision = 1
  	_g.touch = workOutTouchTickBoxValue();

    _g.bulbMeasuringPowerFor = 0;

    _g.stopWatchRunning = false;
    _g.stopWatchTime = 0;

    //createGrid(this);
    createCircuitOutline(this);
    //sliders
    createVoltageSliderBase(this);
    createVoltageSlider(this);
    createResistanceSliderBases(this);
    createResistanceSliders(this);
    //elements
    mapElements();
    //
    initPhysics();
    mapPotentials();
    placeCharges(this);
    initPowerCircles(this);

    const updateAll = () => {
        moveCharges();
        expandPowerCircles();
        updateStopWatch();
    }

    //instead of update
    _g.update = this.time.addEvent({
        delay: _g.tickDelay, //this matches the 12 frames per second of the original FE
        callback: updateAll,
        callbackScope: this,
        loop: true,
    });

    initOptionsArea(this);
    initVoltmeterGraphics(this);
    initAmmeterGraphics(this);
    initPowerMeterGraphics(this);
    initTickBoxes(this);
    initStopWatch(this);

    initDraggableItems(this);
  	//need to initialise components first
  	if(_g.touch) {handleTick(this, 'touch', 'check');}

    changeCellVoltage(6);

}

//extend this
function initOptionsArea(context) {

    const oAX = 815;
    const oAY = 265;

    const oAWidth = 300;
    const oAHeight = 380;

    _g.homeAreaX = oAX - oAWidth / 2;

    const oABox = context.add.rectangle(oAX, oAY, oAWidth, oAHeight, 0xffffff, 1);
    oABox.setStrokeStyle(1, 0x123456, 1);

    const oaHeadingBackground = context.add.rectangle(oAX, oAY - oAHeight / 2 + 10, oAWidth, 20, 0x7576B9, 1);
    const heading = context.add.text(oAX - 80, oAY - oAHeight / 2 + _g.mozArray[4], 'Measurement and display', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#ffffff'
    });

    _g.ammeterHomeX = 740;
    _g.ammeterHomeY = 180;

    _g.voltMeterHomeX = 875;
    _g.voltMeterHomeY = _g.ammeterHomeY;

    _g.powerMeterHomeX = _g.ammeterHomeX;
    _g.powerMeterHomeY = 305;

    _g.stopWatchHomeX = _g.voltMeterHomeX;
    _g.stopWatchHomeY = _g.powerMeterHomeY;

    _g.energyTickHomeX = oAX - oAWidth / 2 + 40;
    _g.energyTickHomeY = 370;

    //maybe add touch home?
}

function initTickBoxes(context) {

    _g.tickBoxLeft = _g.energyTickHomeX;
    _g.tickBoxSide = 20;

    _g.tickBoxEnergyY = _g.energyTickHomeY;

    let left = _g.tickBoxLeft;
    let side = _g.tickBoxSide;
    let energyY = _g.tickBoxEnergyY;

    const textX = left + side;
    const textYNudge = side / 2;

    _g.energyTickBox = context.add.rectangle(left, energyY, side, side, 0xffffff, 1);
    _g.energyTickBox.setStrokeStyle(1, 0x123456, 1);

    _g.energyTickBox.setSize(side, side).setInteractive({
        cursor: 'pointer'
    });

    _g.energyTickBox.on('pointerdown', function(pointer) {

        if (_g.showEnergy) {
            _g.showEnergy = false;
            handleTick(context, 'energy', 'uncheck');
        } else {
            _g.showEnergy = true;
            handleTick(context, 'energy', 'check');
        }


    });

    handleTick(context, 'energy', 'check');


    context.add.text(textX, energyY - textYNudge + _g.mozArray[4], 'Show energy', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#123456'
    });

    //touchTickBox
  	//energy tick box shifted down 60

    _g.tickBox2Left = _g.energyTickHomeX;

    _g.tickBox2touchY = _g.energyTickHomeY + 60;

    let touchY = _g.tickBox2touchY;

    _g.touchTickBox2 = context.add.rectangle(left, touchY, side, side, 0xffffff, 1);
    _g.touchTickBox2.setStrokeStyle(1, 0x123456, 1);

    _g.touchTickBox2.setSize(side, side).setInteractive({
        cursor: 'pointer'
    });

    _g.touchTickBox2.on('pointerdown', function(pointer) {

        if (_g.touch) {
            _g.touch = false;
            handleTick(context, 'touch', 'uncheck');
        } else {
            _g.touch = true;
            handleTick(context, 'touch', 'check');
        }


    });

    //handleTick(context, 'touch', 'check');

    context.add.text(textX, touchY - textYNudge + _g.mozArray[4], 'Touchscreen flexibility', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#123456'
    });

    // could you guess it...
    //precisionTickBox
  	//energy tick box shifted down 30

    touchY -= 30;

    _g.precisionTickBox = context.add.rectangle(left, _g.energyTickHomeY + 30, side, side, 0xffffff, 1);
    _g.precisionTickBox.setStrokeStyle(1, 0x123456, 1);

    _g.precisionTickBox.setSize(side, side).setInteractive({
        cursor: 'pointer'
    });

    _g.precisionTickBox.on('pointerdown', function(pointer) {

      if (_g.precision == 1) {
        _g.precision = 2;
        handleTick(context, 'precision', 'check');
        _g.ammeterOutput.x = -23;
        _g.voltmeterOutput.x = -23;
        _g.powerMeterOutput.x = -22;
      } else {
        _g.precision = 1;
        handleTick(context, 'precision', 'uncheck');
        _g.ammeterOutput.x = -13;
        _g.voltmeterOutput.x = -15;
        _g.powerMeterOutput.x = -12;

      }
      updateAmmeter();
      updateVoltmeter();
      updatePowerMeter();

    });

    //handleTick(context, 'touch', 'check');

    context.add.text(textX, touchY - textYNudge + _g.mozArray[4], '2 d.p.', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#123456'
    });
}

function handleTick(context, type, action) {
    if (type === 'energy') {
        if (action === 'check') {

          	//vars
            const params = evalTickParams(_g.tickBoxLeft,_g.tickBoxSide,3);
			      let tickY = _g.tickBoxEnergyY;
            //create the energy tick
            _g.energyTick = context.add.graphics();
            _g.energyTick.lineStyle(2, 0x123456);
            _g.energyTick.beginPath();

          	//draw it
            _g.energyTick.moveTo(params[0], tickY + params[1]);
            _g.energyTick.lineTo(params[2], tickY + params[3]);
            _g.energyTick.lineTo(params[4], tickY + params[5]);
            _g.energyTick.strokePath();

        } else if (action === 'uncheck') {

            _g.energyTick.clear();

        }
    } else if (type === 'touch') {
        if (action === 'check') {

          	//vars
          	const params = evalTickParams(_g.tickBoxLeft,_g.tickBoxSide,3);
	          let tickY = _g.tickBoxEnergyY+60

            //create the energy tick
            _g.touchTick = context.add.graphics();
            _g.touchTick.lineStyle(2, 0x123456);
            _g.touchTick.beginPath();

          	//draw it
            _g.touchTick.moveTo(params[0], tickY + params[1]);
            _g.touchTick.lineTo(params[2], tickY + params[3]);
            _g.touchTick.lineTo(params[4], tickY + params[5]);
            _g.touchTick.strokePath();
          	//expand touch areas
			touchOption("enable")
          	//set cookie
         	document.cookie = "Touchscreen-c=1;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax"

        } else if (action === 'uncheck') {

            _g.touchTick.clear();
          	//diminish touch areas
          	touchOption("disable")
          	//set cookie
         	document.cookie = "Touchscreen-c=0;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax"
        }
    } else if (type === 'precision') {
    if (action === "check") {

      const params = evalTickParams(_g.tickBoxLeft,_g.tickBoxSide,3);
      let tickY = _g.tickBoxEnergyY+30
      //create the  tick
      _g.preTick = context.add.graphics();
      _g.preTick.lineStyle(2, 0x123456);
      _g.preTick.beginPath();

      //draw it
      _g.preTick.moveTo(params[0], tickY + params[1]);
      _g.preTick.lineTo(params[2], tickY + params[3]);
      _g.preTick.lineTo(params[4], tickY + params[5]);
      _g.preTick.strokePath();

    } else if (action === 'uncheck') {
      _g.preTick.clear();
    }
  }
}

function evalTickParams(left,side,padding) {
    //numbering tick from top left, down to 'v' part and up to top right
    const t1X = left - side / 2 + padding;
    const t1Y = side / 6;

    const t2X = left - side / 6;
    const t2Y = side / 2 - padding;

    const t3X = left + side / 2 - padding;
    const t3Y = side / 2 * -1 + padding;
  	//return
  	return [t1X,t1Y,t2X,t2Y,t3X,t3Y];
}

function touchOption(action) {
	if(action === "enable") {
      //expand touch areas
      _g.ammeter.input.hitArea.setSize(60,60);
      _g.ammeter.input.hitArea.centerX = 15;
      _g.ammeter.input.hitArea.centerY = 15;
      //
      _g.voltmeter.input.hitArea.setSize(60,60);
      _g.voltmeter.input.hitArea.centerX = 15;
      _g.voltmeter.input.hitArea.centerY = 15;
      //
      _g.leftProbe.input.hitArea.setSize(30,30);
      _g.leftProbe.input.hitArea.x = -10
      _g.leftProbe.input.hitArea.y = -10
      //
      _g.rightProbe.input.hitArea.setSize(30,30);
      _g.rightProbe.input.hitArea.x = -10
      _g.rightProbe.input.hitArea.y = -10
      //
      _g.powerMeter.input.hitArea.setSize(80,80);
      _g.powerMeter.input.hitArea.centerX = 20;
      _g.powerMeter.input.hitArea.centerY = 20;
      //
      _g.stopWatch.input.hitArea.setSize(100,100)
      _g.stopWatch.input.hitArea.x = 0
      _g.stopWatch.input.hitArea.y = 0
      _g.stopWatch.input.hitArea.centerX = 41; //50-(100-82)/2
      _g.stopWatch.input.hitArea.centerY = 38; //50-(100-76)/2

    }
  	else if(action === "disable") {
      //diminish touch areas
      _g.ammeter.input.hitArea.setSize(30,30);
      _g.ammeter.input.hitArea.centerX = 15;
      _g.ammeter.input.hitArea.centerY = 15;
      //
      _g.voltmeter.input.hitArea.setSize(30,30);
      _g.voltmeter.input.hitArea.centerX = 15;
      _g.voltmeter.input.hitArea.centerY = 15;
      //
      _g.leftProbe.input.hitArea.setSize(15,15);
      _g.leftProbe.input.hitArea.x = 0
      _g.leftProbe.input.hitArea.y = 0
      //
      _g.rightProbe.input.hitArea.setSize(15,15);
      _g.rightProbe.input.hitArea.x = 0
      _g.rightProbe.input.hitArea.y = 0
      //
      _g.powerMeter.input.hitArea.setSize(40,40);
      _g.powerMeter.input.hitArea.centerX = 20;
      _g.powerMeter.input.hitArea.centerY = 20;
      //
      _g.stopWatch.input.hitArea.setSize(82,76)
      //order is important
      _g.stopWatch.input.hitArea.centerX = 50;
      _g.stopWatch.input.hitArea.centerY = 50;
      _g.stopWatch.input.hitArea.x = 0
      _g.stopWatch.input.hitArea.y = 0
  }
}

function workOutTouchTickBoxValue() {
  res = getCookie("Touchscreen-c");
  if(res === "1") {
  	return true;
  }
  else if(res === "0"){
    //do nothing
  }
  else { //check if touchscreen
  	if(( 'ontouchstart' in window ) || ( navigator.maxTouchPoints > 0 ) || ( navigator.msMaxTouchPoints > 0 )){
      	//expiry date will only work to 2038 on some browsers...
    	document.cookie = "Touchscreen-c=1;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax";
      	return true;
    }
    else {
    	document.cookie = "Touchscreen-c=0;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax";
    }
  }
  return false;
}

function getCookie(cname) { //w3schools.com
  var name = cname+"=";
  var ca = document.cookie.split(';');
  for(var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

function createVoltageSliderBase(context) {

    const centrex = 375;
    const centrey = 90;

    _g.voltageSlideBaseCentreY = centrey;

    const width = 300;
    const height = 50;

    const blx = centrex - (width / 2);
    const bly = centrey + (height / 2);
    const brx = centrex + (width / 2);
    const trY = centrey - (height / 2); //try is a reserved word

    const padl = 10;
    const padr = padl;
    const padb = 5;

    const divisions = 13;
    const spacing = (width - padl - padr) / (divisions - 1);

    const background = context.add.rectangle(centrex, centrey, width, height, 0xD9F8FF);

    const bottomLine = context.add.graphics();
    bottomLine.lineStyle(1, 0x55D4FF);
    bottomLine.beginPath();
    bottomLine.moveTo(blx, bly);
    bottomLine.lineTo(brx, bly);
    bottomLine.strokePath();

    const sideLine = context.add.graphics();
    sideLine.lineStyle(1, 0x55D4FF);
    sideLine.beginPath();
    sideLine.moveTo(brx, bly);
    sideLine.lineTo(brx, trY);
    sideLine.strokePath();

    let currdivx = blx + padl;
    const divby = bly - padb;
    const divHeight = 7;
    const divty = divby - divHeight;

    const fontHeightNudge = 12;
    const singDigitLeftNudge = 4;
    const doubleDigitLeftNudge = 8;
    let leftNudge;
    const valy = divty - padb - fontHeightNudge + _g.mozArray[5];

    const div = context.add.graphics();
    div.lineStyle(1, 0x000000);
    div.beginPath();

    for (let i = 1; i <= divisions; i++) {

        //set the left bound for the slider
        if (i === 1) {
            _g.voltageSliderLeftBound = currdivx;
        }

        //set a value for placing the slide in the right place on the scale
        if (i === (divisions + 1) / 2) { //find the middle value (i.e. 6 V with 0 V start and 12 V end)
            _g.voltageSliderStartX = currdivx;
        }

        //set the right bound for the slider
        if (i === divisions) {
            _g.voltageSliderRightBound = currdivx;
        }

        div.moveTo(currdivx, divby);
        div.lineTo(currdivx, divty);
        div.strokePath();

        if (i - 1 < 10) {
            leftNudge = singDigitLeftNudge;
        } else {
            leftNudge = doubleDigitLeftNudge;
        }

        let value = context.add.text(currdivx - leftNudge, valy, i - 1, {
            fontFamily: 'Arial',
            fontSize: '14px',
            fill: '#1C849D'
        });

        currdivx += spacing;
    }

    const nudgeTitleDown = 4;
    const nudgeTitleRight = 90;

    const title = context.add.text(blx + nudgeTitleRight, trY + nudgeTitleDown + _g.mozArray[6], 'Battery voltage (V)', {
        fontFamily: 'Arial',
        fontSize: '14px',
        fill: '#BF292A'
    });

}

function createVoltageSlider(context) {

    const nudgeDown = 10;

    const centrex = 0;
    const centrey = 0;

    const width = 20;
    const height = 40;

    const blx = centrex - (width / 2);
    const bly = centrey + (height / 2);
    const brx = centrex + (width / 2);
    const trY = centrey - (height / 2); //try is a reserved word


    const sliderBackground = context.add.rectangle(0, 0, width, height, 0x000000, 0.1);

    const bottomLine = context.add.graphics();
    bottomLine.lineStyle(1, 0x55D4FF);
    bottomLine.beginPath();
    bottomLine.moveTo(blx, bly);
    bottomLine.lineTo(brx, bly);
    bottomLine.strokePath();

    const rightLine = context.add.graphics();
    rightLine.lineStyle(1, 0x55D4FF);
    rightLine.beginPath();
    rightLine.moveTo(brx, bly);
    rightLine.lineTo(brx, trY);
    rightLine.strokePath();

    const topLine = context.add.graphics();
    topLine.lineStyle(1, 0xffffff);
    topLine.beginPath();
    topLine.moveTo(blx, trY);
    topLine.lineTo(brx, trY);
    topLine.strokePath();

    const leftLine = context.add.graphics();
    leftLine.lineStyle(1, 0xffffff);
    leftLine.beginPath();
    leftLine.moveTo(blx, bly);
    leftLine.lineTo(blx, trY);
    leftLine.strokePath();

    const markerLine = context.add.graphics();
    markerLine.lineStyle(1, 0xBF292A);
    markerLine.beginPath();
    markerLine.moveTo(centrex, bly);
    markerLine.lineTo(centrex, trY);
    markerLine.strokePath();

    _g.voltageSlider = context.add.container(_g.voltageSliderStartX, _g.voltageSlideBaseCentreY + nudgeDown, [sliderBackground, bottomLine, rightLine, topLine, leftLine, markerLine]);

    //setSize sets hit area for interactive
    _g.voltageSlider.setSize(width, height).setInteractive({
        cursor: 'pointer'
    });

}

function createResistanceSliderBases(context) {

    //make sure the left slider and right slider are equally spaced
    const distanceInFromEdge = 100;

    const centre1x = _g.lox + distanceInFromEdge;
    const centre2x = _g.rox - distanceInFromEdge;

    const centrey = 500;

    _g.resistanceSlideBaseCentreY = centrey;

    const aspectRatio = 6; //the width is 6 x the height

    const width = 220;
    const height = width / aspectRatio;

    const bl1x = centre1x - (width / 2);
    const br1x = centre1x + (width / 2);

    const bl2x = centre2x - (width / 2);
    const br2x = centre2x + (width / 2);

    const bly = centrey + (height / 2);
    const trY = centrey - (height / 2); //try is a reserved word

    const padl = 10;
    const padr = padl;
    const padb = 3;

    const scaleStart = 3;
    const scaleEnd = 24;
    const divisions = scaleEnd - scaleStart + 1; //resistance range 3 - 24, so 22 values
    const spacing = (width - padl - padr) / (divisions - 1);

    const background1 = context.add.rectangle(centre1x, centrey, width, height, 0xD9F8FF);
    const background2 = context.add.rectangle(centre2x, centrey, width, height, 0xD9F8FF);

    const bottomLine1 = context.add.graphics();
    bottomLine1.lineStyle(1, 0x55D4FF);
    bottomLine1.beginPath();
    bottomLine1.moveTo(bl1x, bly);
    bottomLine1.lineTo(br1x, bly);
    bottomLine1.strokePath();

    const sideLine1 = context.add.graphics();
    sideLine1.lineStyle(1, 0x55D4FF);
    sideLine1.beginPath();
    sideLine1.moveTo(br1x, bly);
    sideLine1.lineTo(br1x, trY);
    sideLine1.strokePath();

    const bottomLine2 = context.add.graphics();
    bottomLine2.lineStyle(1, 0x55D4FF);
    bottomLine2.beginPath();
    bottomLine2.moveTo(bl2x, bly);
    bottomLine2.lineTo(br2x, bly);
    bottomLine2.strokePath();

    const sideLine2 = context.add.graphics();
    sideLine2.lineStyle(1, 0x55D4FF);
    sideLine2.beginPath();
    sideLine2.moveTo(br2x, bly);
    sideLine2.lineTo(br2x, trY);
    sideLine2.strokePath();

    let currdiv1x = bl1x + padl;
    let currdiv2x = bl2x + padl;

    const divby = bly - padb;
    const divHeight = 3;
    const divty = divby - divHeight;

    const fontHeightNudge = 10;
    const singDigitLeftNudge = 3;
    const doubleDigitLeftNudge = 7;
    let leftNudge;
    const valy = divty - padb - fontHeightNudge + _g.mozArray[8];

    const startResistance = 6;
    let scaleValue = scaleStart;
    const scaleDisplayInterval = 3;

    const div = context.add.graphics();
    div.lineStyle(1, 0x000000);
    div.beginPath();

    for (let i = 1; i <= divisions; i++) {

        //set the left bound for the slider
        if (i === 1) {
            _g.resistanceSlider1LeftBound = currdiv1x;
            _g.resistanceSlider2LeftBound = currdiv2x;
        }

        //set a value for placing the slide in the right place on the scale
        if (scaleValue === startResistance) { //find the middle value (i.e. 6 V with 0 V start and 12 V end)
            _g.resistanceSlider1StartX = currdiv1x;
            _g.resistanceSlider2StartX = currdiv2x;
        }

        //set the right bound for the slider
        if (i === divisions) {
            _g.resistanceSlider1RightBound = currdiv1x;
            _g.resistanceSlider2RightBound = currdiv2x;
        }

        div.moveTo(currdiv1x, divby);
        div.lineTo(currdiv1x, divty);
        div.strokePath();

        div.moveTo(currdiv2x, divby);
        div.lineTo(currdiv2x, divty);
        div.strokePath();

        if (scaleValue < 10) {
            leftNudge = singDigitLeftNudge;
        } else {
            leftNudge = doubleDigitLeftNudge;
        }

        const valueFontSize = '11px';

        if (scaleValue % scaleDisplayInterval === 0) {
            let value1 = context.add.text(currdiv1x - leftNudge, valy, scaleValue, {
                fontFamily: 'Arial',
                fontSize: valueFontSize,
                fill: '#1C849D'
            });
            let value2 = context.add.text(currdiv2x - leftNudge, valy, scaleValue, {
                fontFamily: 'Arial',
                fontSize: valueFontSize,
                fill: '#1C849D'
            });
        }

        currdiv1x += spacing;
        currdiv2x += spacing;

        scaleValue++;
    }

    const nudgeTitleDown = 2;
    const nudgeTitleRight = 50;

    const titleFontSize = '12px';

    const title1 = context.add.text(bl1x + nudgeTitleRight, trY + nudgeTitleDown + _g.mozArray[7], 'Bulb resistance (ohms)', {
        fontFamily: 'Arial',
        fontSize: titleFontSize,
        fill: '#000000'
    });
    const title2 = context.add.text(bl2x + nudgeTitleRight, trY + nudgeTitleDown + _g.mozArray[7], 'Bulb resistance (ohms)', {
        fontFamily: 'Arial',
        fontSize: titleFontSize,
        fill: '#000000'
    });

}

function createResistanceSliders(context) {

    const nudgeDown = 10;

    const centrex = 0;
    const centrey = 0;

    const aspectRatio = 2; //twice as high as wide

    const width = 14;
    const height = width * aspectRatio;

    const blx = centrex - (width / 2);
    const bly = centrey + (height / 2);
    const brx = centrex + (width / 2);
    const trY = centrey - (height / 2); //try is a reserved word


    const slider1Background = context.add.rectangle(0, 0, width, height, 0x000000, 0.1);
    const slider2Background = context.add.rectangle(0, 0, width, height, 0x000000, 0.1);

    const bottomLine1 = context.add.graphics();
    bottomLine1.lineStyle(1, 0x55D4FF);
    bottomLine1.beginPath();
    bottomLine1.moveTo(blx, bly);
    bottomLine1.lineTo(brx, bly);
    bottomLine1.strokePath();

    const bottomLine2 = context.add.graphics();
    bottomLine2.lineStyle(1, 0x55D4FF);
    bottomLine2.beginPath();
    bottomLine2.moveTo(blx, bly);
    bottomLine2.lineTo(brx, bly);
    bottomLine2.strokePath();

    const rightLine1 = context.add.graphics();
    rightLine1.lineStyle(1, 0x55D4FF);
    rightLine1.beginPath();
    rightLine1.moveTo(brx, bly);
    rightLine1.lineTo(brx, trY);
    rightLine1.strokePath();

    const rightLine2 = context.add.graphics();
    rightLine2.lineStyle(1, 0x55D4FF);
    rightLine2.beginPath();
    rightLine2.moveTo(brx, bly);
    rightLine2.lineTo(brx, trY);
    rightLine2.strokePath();

    const topLine1 = context.add.graphics();
    topLine1.lineStyle(1, 0xffffff);
    topLine1.beginPath();
    topLine1.moveTo(blx, trY);
    topLine1.lineTo(brx, trY);
    topLine1.strokePath();

    const topLine2 = context.add.graphics();
    topLine2.lineStyle(1, 0xffffff);
    topLine2.beginPath();
    topLine2.moveTo(blx, trY);
    topLine2.lineTo(brx, trY);
    topLine2.strokePath();

    const leftLine1 = context.add.graphics();
    leftLine1.lineStyle(1, 0xffffff);
    leftLine1.beginPath();
    leftLine1.moveTo(blx, bly);
    leftLine1.lineTo(blx, trY);
    leftLine1.strokePath();

    const leftLine2 = context.add.graphics();
    leftLine2.lineStyle(1, 0xffffff);
    leftLine2.beginPath();
    leftLine2.moveTo(blx, bly);
    leftLine2.lineTo(blx, trY);
    leftLine2.strokePath();

    const markerLine1 = context.add.graphics();
    markerLine1.lineStyle(1, 0xBF292A);
    markerLine1.beginPath();
    markerLine1.moveTo(centrex, bly);
    markerLine1.lineTo(centrex, trY);
    markerLine1.strokePath();

    const markerLine2 = context.add.graphics();
    markerLine2.lineStyle(1, 0xBF292A);
    markerLine2.beginPath();
    markerLine2.moveTo(centrex, bly);
    markerLine2.lineTo(centrex, trY);
    markerLine2.strokePath();

    _g.resistanceSlider1 = context.add.container(_g.resistanceSlider1StartX, _g.resistanceSlideBaseCentreY + nudgeDown, [slider1Background, bottomLine1, rightLine1, topLine1, leftLine1, markerLine1]);
    _g.resistanceSlider2 = context.add.container(_g.resistanceSlider2StartX, _g.resistanceSlideBaseCentreY + nudgeDown, [slider2Background, bottomLine2, rightLine2, topLine2, leftLine2, markerLine2]);

    //setSize sets hit area for interactive
    _g.resistanceSlider1.setSize(width, height).setInteractive({
        cursor: 'pointer'
    });
    _g.resistanceSlider2.setSize(width, height).setInteractive({
        cursor: 'pointer'
    });

}

function initVoltmeterGraphics(context) {

    const voltmeterShadow = context.add.circle(3, 3, 30, 0x000000, 0.1);
    _g.voltmeterBackground = context.add.circle(0, 0, 30, 0x00ff00, 0.5);
    const titleBackground = context.add.rectangle(0, -38, 80, 20, 0e000000, 0.5);

    const title = context.add.text(-32, -46+_g.mozArray[0], 'Voltmeter', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#ffffff'
    });

    _g.voltmeterOutput = context.add.text(-15, -15+_g.mozArray[1], '--.-', {
        fontFamily: 'Arial',
        fontSize: '24px',
        fill: '#000000'
    });
    const unitDisplay = context.add.text(-17, 10+_g.mozArray[2], 'VOLTS', {
        fontFamily: 'Arial',
        fontSize: '10px',
        fill: '#000000'
    });


    _g.leftConnection = context.add.circle(-33, 0, 6, 0x000000);
    _g.rightConnection = context.add.circle(33, 0, 6, 0x000000);

    _g.leftLeadHome = {
        startx: -30,
        starty: 0,
        endx: -60,
        endy: 0
    };
    _g.rightLeadHome = {
        startx: 30,
        starty: 0,
        endx: 60,
        endy: 0
    };

    _g.leftProbe = context.add.circle(0, 0, 15, 0xaaaaaa).setInteractive({
        cursor: 'pointer'
    });
    _g.rightProbe = context.add.circle(0, 0, 15, 0xaaaaaa).setInteractive({
        cursor: 'pointer'
    });

    _g.rightProbeVoltage = -1; //these are the 'not on a wire' defaults
    _g.leftProbeVoltage = -1;

    _g.leftProbe.locked = false;
    _g.rightProbe.locked = false;

    _g.rightLead = context.add.graphics();
    _g.rightLead.lineStyle(4, 0xff6633);
    _g.rightLead.beginPath();

    _g.leftLead = context.add.graphics();
    _g.leftLead.lineStyle(4, 0xff6633);
    _g.leftLead.beginPath();

    //_g.voltmeterLeftProbe = context.add.circle(-30, 0, 6, 0x000000);
    xs = _g.voltmeterBackground.width
    ys = _g.voltmeterBackground.width

    _g.voltmeter = context.add.container(_g.voltMeterHomeX, _g.voltMeterHomeY, [voltmeterShadow, _g.voltmeterBackground, _g.leftConnection, _g.rightConnection, titleBackground, title, _g.voltmeterOutput, unitDisplay]);
    //setSize sets hit area for interactive
    _g.voltmeter.setSize(xs, ys).setInteractive({
        cursor: 'pointer'
    });
    _g.voltmeter.setDepth(1);

    leadSnapBack('left', context);
    leadSnapBack('right', context);

}

function leadSnapBack(lead, context) {

    let vm = _g.voltmeter;

    if (lead === 'left') {

        _g.leftLead.clear();
        _g.leftLead.lineStyle(4, 0xff6633);

        _g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
        _g.leftLead.lineTo(vm.x + _g.leftLeadHome.endx, vm.y + _g.leftLeadHome.endy);
        _g.leftLead.strokePath();

        _g.leftProbe.x = vm.x + _g.leftLeadHome.endx;
        _g.leftProbe.y = vm.y + _g.leftLeadHome.endy;
        _g.leftProbe.bounds = _g.leftProbe.getBounds();

    } else if (lead === 'right') {

        _g.rightLead.clear();
        _g.rightLead.lineStyle(4, 0xff6633);

        _g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
        _g.rightLead.lineTo(vm.x + _g.rightLeadHome.endx, vm.y + _g.rightLeadHome.endy);
        _g.rightLead.strokePath();

        _g.rightProbe.x = vm.x + _g.rightLeadHome.endx;
        _g.rightProbe.y = vm.y + _g.rightLeadHome.endy;
        _g.rightProbe.bounds = _g.rightProbe.getBounds();

    }

}

function initAmmeterGraphics(context) {

    const ammeterShadow = context.add.circle(3, 3, 30, 0x000000, 0.1);
    const background = context.add.circle(0, 0, 30, 0xFF43FF, 0.8);
    //const hitarea = context.add.circle(0 , 0 , 60, 0x000000, 0); //Opaque hit area
    const titleBackground = context.add.rectangle(0, -38, 80, 20, 0e000000, 0.5);
    const title = context.add.text(-32, -46+_g.mozArray[0], 'Ammeter', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#ffffff'
    });

    _g.ammeterOutput = context.add.text(-13, -15+_g.mozArray[1], '-.-', {
        fontFamily: 'Arial',
        fontSize: '24px',
        fill: '#000000'
    });
    const unitDisplay = context.add.text(-13, 10+_g.mozArray[2], 'AMPS', {
        fontFamily: 'Arial',
        fontSize: '10px',
        fill: '#000000'
    });

    //_g.ammeter = context.add.container(700, 250, [ ammeterShadow, background, titleBackground, title, _g.ammeterOutput, unitDisplay ]);
    _g.ammeter = context.add.container(_g.ammeterHomeX, _g.ammeterHomeY, [ammeterShadow, background, titleBackground, title, _g.ammeterOutput, unitDisplay]);
    //setSize sets hit area for interactive
    _g.ammeter.setSize(background.width, background.height).setInteractive({cursor: 'pointer'});
    _g.ammeter.setDepth(2);
  	_g.ammeter.background = background;

}

function initPowerMeterGraphics(context) {

    const powerMeterShadow = context.add.circle(3, 3, 40, 0x000000, 0.1);
    const background = context.add.circle(0, 0, 40, 0xffffff, 0.2);
    //const hitarea = context.add.circle(0 , 0 , 80, 0x000000, 0); //Opaque hit area
    const titleBackground = context.add.rectangle(3, -38, 100, 20, 0x000000, 0.5);
    const title = context.add.text(-40, -46+_g.mozArray[0], 'Power meter', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#ffffff'
    });

    _g.powerMeterOutput = context.add.text(-12, -15+_g.mozArray[1], '-.-', {
        fontFamily: 'Arial',
        fontSize: '24px',
        fill: '#000000'
    });
    const unitDisplay = context.add.text(-13, 10+_g.mozArray[2], 'WATTS', {
        fontFamily: 'Arial',
        fontSize: '10px',
        fill: '#000000'
    });

    _g.powerMeter = context.add.container(_g.powerMeterHomeX, _g.powerMeterHomeY, [powerMeterShadow, background, titleBackground, title, _g.powerMeterOutput, unitDisplay]);
    //setSize sets hit area for interactive
    _g.powerMeter.setSize(background.width, background.height).setInteractive({
        cursor: 'pointer'
    });
    _g.powerMeter.setDepth(4);

}

function initStopWatch(context) {

    const stopWatchX = _g.stopWatchHomeX;
    const stopWatchY = _g.stopWatchHomeY;

    //_g.stopWatchX = stopWatchX;
    //_g.stopWatchY = stopWatchY;

    _g.stopWatchStartStopXOffset = -12;
    _g.stopWatchStartStopYOffset = 22;

    _g.stopWatchResetXOffset = 18;
    _g.stopWatchResetYOffset = 17;

    const shadow = context.add.circle(3, 3, 50, 0x000000, 0.1);
    const rim = context.add.circle(0, 0, 50, 0xF8C646, 1);
    const face = context.add.circle(0, 0, 40, 0xE5AF2B, 1);
    const titleBackground = context.add.rectangle(0, -38, 82, 20, 0x000000, 0.5);
    const title = context.add.text(-34, -46+_g.mozArray[0], 'Stopwatch', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#ffffff'
    });
    const numberBackground = context.add.rectangle(0, -8, 58, 30, 0xEBEEEC, 1);
    //const hitarea = context.add.circle(0 , 0 , 60, 0x000000, 0); //Opaque hit area

    _g.stopWatchOutput = context.add.text(-16, -23+_g.mozArray[1], '0.0', {
        fontFamily: 'Arial',
        fontSize: '24px',
        fill: '#000000'
    });

    const unitDisplay = context.add.text(-17, -1+_g.mozArray[3], 'SECONDS', {
        fontFamily: 'Arial',
        fontSize: '7px',
        fill: '#000000'
    });
    _g.stopWatch = context.add.container(stopWatchX, stopWatchY, [shadow, rim, face, titleBackground, title, numberBackground, _g.stopWatchOutput, unitDisplay]);
    // ???
    _g.stopWatch.setSize(82, 76).setInteractive({
        cursor: 'pointer'
    });
    _g.stopWatch.setDepth(10);

    const startStopRim = context.add.circle(0, 0, 12, 0xCF2037, 1);
    const startStopSurface = context.add.circle(0, 0, 10, 0xF5626C, 1);
    _g.startStopButton = context.add.container(stopWatchX + _g.stopWatchStartStopXOffset, stopWatchY + _g.stopWatchStartStopYOffset, [startStopRim, startStopSurface]);
    _g.startStopButton.setSize(30, 30).setInteractive({
        cursor: 'pointer'
    });
    _g.startStopButton.setDepth(11);

    _g.startStopButton.on('pointerdown', function() {

        if (_g.stopWatchRunning) {
            _g.stopWatchRunning = false;
        } else {
            _g.stopWatchRunning = true;
        }

    });

    const resetBackground = context.add.rectangle(0, 0, 20, 12, 0x4F4F46, 1);
    const resetSurface = context.add.rectangle(0, 0, 18, 10, 0xB2A4A2, 1);
    _g.resetButton = context.add.container(stopWatchX + _g.stopWatchResetXOffset, stopWatchY + _g.stopWatchResetYOffset, [resetBackground, resetSurface]);
    _g.resetButton.setSize(20, 12).setInteractive({
        cursor: 'pointer'
    });
    _g.resetButton.setDepth(11);


    _g.resetButton.on('pointerdown', function() {

        _g.stopWatchRunning = false;
        resetStopWatch();

    });

    _g.stopWatchIncrement = _g.tickDelay / 1000;
    _g.stopWatchSingleDigit = _g.stopWatchOutput.x;

}

function updateStopWatch() {

    const doubleDigitNudge = 7; // moves display left when double digit seconds

    if (_g.stopWatchRunning) {
        _g.stopWatchTime += _g.stopWatchIncrement;

        if (_g.stopWatchTime > 60) {
            resetStopWatch();
        } else if (_g.stopWatchTime >= 10) {
            _g.stopWatchOutput.x = _g.stopWatchSingleDigit - doubleDigitNudge;
        } else {
            _g.stopWatchOutput.x = _g.stopWatchSingleDigit;
        }

        let roundedTime = displayToNdp(_g.stopWatchTime,1);

        _g.stopWatchOutput.setText(roundedTime);
    }

}

function resetStopWatch() {
    _g.stopWatchTime = 0;
    _g.stopWatchOutput.x = _g.stopWatchSingleDigit;
    _g.stopWatchOutput.setText('0.0');
}

function update() {
    if (_g.dragging) {

        if (_g.dragged === 'voltageSlider') {
            handleVoltageSlider();
        } else if (_g.dragged === 'resistanceSlider1') {
            handleResistanceSlider(1);
        } else if (_g.dragged === 'resistanceSlider2') {
            handleResistanceSlider(2);
        } else if (_g.dragged === 'leftProbe') {
            handleDragLeftProbe();
        } else if (_g.dragged === 'rightProbe') {
            handleDragRightProbe();
        } else if (_g.dragged === 'voltmeter') {
            dragVoltmeter();
        } else if (_g.dragged === 'ammeter') {
            dragAmmeter();
        } else if (_g.dragged === 'powerMeter') {
            dragPowerMeter();
        } else if (_g.dragged === 'stopWatch') {
            dragStopWatch();
        }
    }
}

function handleDragLeftProbe() {

    let vm = _g.voltmeter;

    _g.leftProbe.x = vm.x + _g.leftLeadHome.endx;
    _g.leftProbe.y = vm.y + _g.leftLeadHome.endy;
    _g.leftProbe.bounds = _g.leftProbe.getBounds();

    _g.draggedObject.x = _g.pointerx - _g.xOffset;
    _g.draggedObject.y = _g.pointery - _g.yOffset;

    _g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

    _g.leftLead.clear();
    _g.leftLead.lineStyle(4, 0xff6633);

    _g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
    _g.leftLead.lineTo(_g.draggedObject.x, _g.draggedObject.y);
    _g.leftLead.strokePath();

    _g.leftProbeVoltage = getProbeVoltage();

    updateVoltmeter();
}

function handleDragRightProbe() {

    let vm = _g.voltmeter;

    _g.rightProbe.x = vm.x + _g.rightLeadHome.endx;
    _g.rightProbe.y = vm.y + _g.rightLeadHome.endy;
    _g.rightProbe.bounds = _g.rightProbe.getBounds();

    _g.draggedObject.x = _g.pointerx - _g.xOffset;
    _g.draggedObject.y = _g.pointery - _g.yOffset;

    _g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

    _g.rightLead.clear();
    _g.rightLead.lineStyle(4, 0xff6633);

    _g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
    _g.rightLead.lineTo(_g.draggedObject.x, _g.draggedObject.y);
    _g.rightLead.strokePath();

    _g.rightProbeVoltage = getProbeVoltage();

    updateVoltmeter();
}

//if the voltmeter is dragged while the lead is on a wire, keep it where it is
function updateLeadWhileLocked(probe) {

    let vm = _g.voltmeter;

    if (probe === 'left') {

        _g.leftLead.clear();
        _g.leftLead.lineStyle(4, 0xff6633);

        _g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
        _g.leftLead.lineTo(_g.leftProbe.x, _g.leftProbe.y);
        _g.leftLead.strokePath();

    } else if (probe === 'right') {

        _g.rightLead.clear();
        _g.rightLead.lineStyle(4, 0xff6633);

        _g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
        _g.rightLead.lineTo(_g.rightProbe.x, _g.rightProbe.y);
        _g.rightLead.strokePath();

    }
}

function checkVoltmeterProbes() {

    if (_g.rightProbeVoltage != -1) {
        _g.rightProbe.locked = true;
    } else {
        _g.rightProbe.locked = false;
        leadSnapBack('right');
    }

    if (_g.leftProbeVoltage != -1) {
        _g.leftProbe.locked = true;
    } else {
        _g.leftProbe.locked = false;
        leadSnapBack('left');
    }

    updateVoltmeter();
}

function dragVoltmeter() {
    _g.draggedObject.x = _g.pointerx - _g.xOffset;
    _g.draggedObject.y = _g.pointery - _g.yOffset;

    if (_g.leftProbe.locked) {
        updateLeadWhileLocked('left');
    } else {
        leadSnapBack('left');
    }

    if (_g.rightProbe.locked) {
        updateLeadWhileLocked('right');
    } else {
        leadSnapBack('right');
    }

    _g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();
}

function dragAmmeter() {

    _g.draggedObject.x = _g.pointerx - _g.xOffset;
    _g.draggedObject.y = _g.pointery - _g.yOffset;

    zone = getAmmeterCurrent(); //-1 if ammeter is not on wire

    if (zone != -1) {
        _g.ammeterOnWire = true;
    } else {
        _g.ammeterOnWire = false;
    }

    updateAmmeter();

    _g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
}

function dragStopWatch() {

    _g.draggedObject.x = _g.pointerx - _g.xOffset;
    _g.draggedObject.y = _g.pointery - _g.yOffset;

    _g.startStopButton.x = _g.stopWatch.x + _g.stopWatchStartStopXOffset;
    _g.startStopButton.y = _g.stopWatch.y + _g.stopWatchStartStopYOffset;

    _g.resetButton.x = _g.stopWatch.x + _g.stopWatchResetXOffset;
    _g.resetButton.y = _g.stopWatch.y + _g.stopWatchResetYOffset;

    _g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();

}

function dragPowerMeter() {

    _g.draggedObject.x = _g.pointerx - _g.xOffset;
    _g.draggedObject.y = _g.pointery - _g.yOffset;

    _g.bulbMeasuringPowerFor = getBulbIDForPower();

    updatePowerMeter();

    _g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
}

function updatePowerMeter() {

    let powerMeterDisplay;

    if (_g.bulbMeasuringPowerFor) {
  		if (_g.precision === 2) _g.powerMeterOutput.x = -22;
  		else _g.powerMeterOutput.x = -12;
  		powerMeterDisplay = displayToNdp(_g["physPower"+_g.bulbMeasuringPowerFor],
  			_g.precision);
  	}
  	else {
  		_g.powerMeterOutput.x = -12;
  		powerMeterDisplay = '-.-';
  	}

    _g.powerMeterOutput.setText(powerMeterDisplay);


}

function getBulbIDForPower() {

    let found = false;

    let probex = _g.draggedObject.x;
    let probey = _g.draggedObject.y;

    let bulb;

    //for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

    if (pointIsInBox(probex, probey, _g.b1lix, _g.bulbTopy, _g.b1rix, _g.biy)) {

        found = true;
        bulb = 1;

    } else if (pointIsInBox(probex, probey, _g.b2lix, _g.bulbTopy, _g.b2rix, _g.biy)) {

        found = true;
        bulb = 2;

    } else {
        found = false;
        bulb = 0
    }

    return bulb;

}

function getProbeVoltage(source, probe) {

    let found = false;

    let probex;
    let probey;

    if (source === 'resistance slider') {
        if (probe === 'left') {
            probex = _g.leftProbe.x;
            probey = _g.leftProbe.y;
        }

        if (probe === 'right') {
            probex = _g.rightProbe.x;
            probey = _g.rightProbe.y;
        }
    } else {
        probex = _g.draggedObject.x;
        probey = _g.draggedObject.y;
    }

    let zone;

    let distanceRoundBulb = Math.PI * (_g.blr - _g.bsr); //measure around the middle of the wire
    let bulbPdLength = distanceRoundBulb + _g.ww; //each short vertical is half a wire width - two verticals for a bulb

    const proportionDroppedAcrossBulb1 = _g.bulb1pd / (_g.bulb1pd + _g.bulb2pd);
    const proportionDroppedAcrossBulb2 = _g.bulb2pd / (_g.bulb1pd + _g.bulb2pd);

    //for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
    if (pointIsInBox(probex, probey, _g.lox, _g.toy, _g.clx, _g.tiy)) { //check zone 1
        found = true;
        zone = 1;
        _g.measuredVoltageProportion = 1;
    } else if (pointIsInBox(probex, probey, _g.lox, _g.tiy, _g.lix, _g.boy)) { //check zone 2
        found = true;
        zone = 2;
        _g.measuredVoltageProportion = 1;
    } else if (pointIsInBox(probex, probey, _g.lix, _g.biy, _g.b1lix, _g.boy)) { //check zone 3
        found = true;
        zone = 3;
        _g.measuredVoltageProportion = 1;
    } else if (pointIsInBox(probex, probey, _g.b1lix, _g.biy, _g.b1lox, _g.boy)) { //check zone 4
        found = true;
        zone = 4;

        //As you go up from the middle of the wire upwards towards the beginning of the curve, the potential drops
        let startY = _g.boy - _g.ww / 2; //start half a wire thickness from the bottom

        if (probey < startY) { //only reduce potential above midline
            _g.measuredVoltageProportion = 1 - (proportionDroppedAcrossBulb1 * (startY - probey) / bulbPdLength);
        } else {
            _g.measuredVoltageProportion = 1;
        }


    } else if (pointIsInBox(probex, probey, _g.b1lix, _g.bulbTopy, _g.b1rix, _g.biy)) { //check zone 5 - left bulb

        //you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
        let base = probex - _g.b1cx;
        let height = _g.biy - probey;

        let distanceFromCentre = Math.sqrt(Math.pow(base, 2) + Math.pow(height, 2));

        if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
            found = true;
            zone = 5;

            //get the angle of the pointer with the centre of the curve - use cos to get the full angle range from Pi to -Pi
            //subtract this from Pi so the distance from the start begins at 0, not Pi
            let pointerAngleRadians = Math.acos(base / distanceFromCentre);

            let distanceFromCurveStart = (Math.PI - pointerAngleRadians) * (_g.blr - _g.bsr);
            _g.measuredVoltageProportion = 1 - (proportionDroppedAcrossBulb1 * (_g.ww / 2 + distanceFromCurveStart) / bulbPdLength);
        }

    } else if (pointIsInBox(probex, probey, _g.b1rox, _g.biy, _g.b1rix, _g.boy)) { //check zone 6
        found = true;
        zone = 6;

        //As you go up from the top of the wire downwards towards the middle, the potential drops
        let startY = _g.biy;

        if (probey < _g.boy - _g.ww / 2) { //only reduce potential above midline
            _g.measuredVoltageProportion = 1 - (proportionDroppedAcrossBulb1 * (_g.ww / 2 + distanceRoundBulb + (probey - startY)) / bulbPdLength);
        } else {
            _g.measuredVoltageProportion = 1 - proportionDroppedAcrossBulb1;
        }

    } else if (pointIsInBox(probex, probey, _g.b1rix, _g.biy, _g.b2lix, _g.boy)) { //check zone 7
        found = true;
        zone = 7;
        _g.measuredVoltageProportion = 1 - proportionDroppedAcrossBulb1;
    } else if (pointIsInBox(probex, probey, _g.b2lix, _g.biy, _g.b2lox, _g.boy)) { //check zone 8
        found = true;
        zone = 8;

        //As you go up from the middle of the wire upwards towards the beginning of the curve, the potential drops
        let startY = _g.boy - _g.ww / 2; //start half a wire thickness from the bottom

        if (probey < startY) { //only reduce potential above midline
            _g.measuredVoltageProportion = 1 - proportionDroppedAcrossBulb1 - (proportionDroppedAcrossBulb1 * (startY - probey) / bulbPdLength);
        } else {
            _g.measuredVoltageProportion = 1 - proportionDroppedAcrossBulb1;
        }


    } else if (pointIsInBox(probex, probey, _g.b2lix, _g.bulbTopy, _g.b2rix, _g.biy)) { //check zone 9 - right bulb

        //you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
        let base = probex - _g.b2cx;
        let height = _g.biy - probey;

        let distanceFromCentre = Math.sqrt(Math.pow(base, 2) + Math.pow(height, 2));

        if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
            found = true;
            zone = 9;

            //get the angle of the pointer with the centre of the curve - use cos to get the full angle range from Pi to -Pi
            //subtract this from Pi so the distance from the start begins at 0, not Pi
            let pointerAngleRadians = Math.acos(base / distanceFromCentre);

            let distanceFromCurveStart = (Math.PI - pointerAngleRadians) * (_g.blr - _g.bsr);
            _g.measuredVoltageProportion = 1 - proportionDroppedAcrossBulb1 - (proportionDroppedAcrossBulb2 * (_g.ww / 2 + distanceFromCurveStart) / bulbPdLength);
        }

    } else if (pointIsInBox(probex, probey, _g.b2rox, _g.biy, _g.b2rix, _g.boy)) { //check zone 10
        found = true;
        zone = 10;

        //As you go up from the top of the wire downwards towards the middle, the potential drops
        let startY = _g.biy;

        if (probey < _g.boy - _g.ww / 2) { //only reduce potential above midline
            _g.measuredVoltageProportion = 1 - proportionDroppedAcrossBulb1 - (proportionDroppedAcrossBulb2 * (_g.ww / 2 + distanceRoundBulb + (probey - startY)) / bulbPdLength);
        } else {
            _g.measuredVoltageProportion = 0;
        }

    } else if (pointIsInBox(probex, probey, _g.b2rix, _g.biy, _g.rox, _g.boy)) { //check zone 11
        found = true;
        zone = 11;
        _g.measuredVoltageProportion = 0;
    } else if (pointIsInBox(probex, probey, _g.rix, _g.toy, _g.rox, _g.biy)) { //check zone 12
        found = true;
        zone = 12;
        _g.measuredVoltageProportion = 0;
    } else if (pointIsInBox(probex, probey, _g.crx, _g.toy, _g.rix, _g.tiy)) { //check zone 13
        found = true;
        zone = 13;
        _g.measuredVoltageProportion = 0;
    }

    if (found) {
        return _g.measuredVoltageProportion;
        updateVoltmeter();
    } else {
        return -1;
    }
}

function updateVoltmeter() {

  let pdProportion; // independent of battery voltage

  if(_g.leftProbeVoltage === -1 || _g.rightProbeVoltage === -1) {
    _g.voltmeterOutput.x = -15;
    _g.voltmeterDisplay = '--.-';
    _g.voltmeterOutput.setText(_g.voltmeterDisplay);
  } else {
    pdProportion = Math.abs(_g.leftProbeVoltage - _g.rightProbeVoltage);

    // need to do this first
    _g.voltmeterDisplay = displayToNdp(_g.physCellVoltage * pdProportion,
      _g.precision);
    _g.voltmeterOutput.setText(_g.voltmeterDisplay);

    // sort out alignment of text based on value
    if (_g.precision === 2) {
      if(_g.voltmeterDisplay.length === 4) _g.voltmeterOutput.x = -23;
      else _g.voltmeterOutput.x = -31;
    }
    else {
      if(_g.voltmeterDisplay.length === 3) _g.voltmeterOutput.x = -17;
      else _g.voltmeterOutput.x = -23;
    }
  }

}

function updateAmmeter() {

  if (_g.ammeterOnWire) {

    if (_g.precision === 2) _g.ammeterOutput.x = -23;
    else _g.ammeterOutput.x = -13;
    _g.ammeterDisplay = displayToNdp(_g.physCurrent, _g.precision);
  } else {
    _g.ammeterOutput.x = -13;
    _g.ammeterDisplay = '-.-';
  }

  _g.ammeterOutput.setText(_g.ammeterDisplay);
}

function getAmmeterCurrent() {

    let found = false;

    let probex = _g.draggedObject.x;
    let probey = _g.draggedObject.y;

    let zone;

    let distanceRoundBulb = Math.PI * (_g.blr - _g.bsr); //measure around the middle of the wire

    //for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
    if (pointIsInBox(probex, probey, _g.lox, _g.toy, _g.clx, _g.tiy)) { //check zone 1
        found = true;
        zone = 1;

    } else if (pointIsInBox(probex, probey, _g.lox, _g.tiy, _g.lix, _g.boy)) { //check zone 2
        found = true;
        zone = 2;

    } else if (pointIsInBox(probex, probey, _g.lix, _g.biy, _g.b1lix, _g.boy)) { //check zone 3
        found = true;
        zone = 3;

    } else if (pointIsInBox(probex, probey, _g.b1lix, _g.biy, _g.b1lox, _g.boy)) { //check zone 4
        found = true;
        zone = 4;

    } else if (pointIsInBox(probex, probey, _g.b1lix, _g.bulbTopy, _g.b1rix, _g.biy)) { //check zone 5 - left bulb

        //you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
        let base = probex - _g.b1cx;
        let height = _g.biy - probey;

        let distanceFromCentre = Math.sqrt(Math.pow(base, 2) + Math.pow(height, 2));

        if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
            found = true;
            zone = 5;
        }

    } else if (pointIsInBox(probex, probey, _g.b1rox, _g.biy, _g.b1rix, _g.boy)) { //check zone 6
        found = true;
        zone = 6;

    } else if (pointIsInBox(probex, probey, _g.b1rix, _g.biy, _g.b2lix, _g.boy)) { //check zone 7
        found = true;
        zone = 7;

    } else if (pointIsInBox(probex, probey, _g.b2lix, _g.biy, _g.b2lox, _g.boy)) { //check zone 8
        found = true;
        zone = 8;

    } else if (pointIsInBox(probex, probey, _g.b2lix, _g.bulbTopy, _g.b2rix, _g.biy)) { //check zone 9 - right bulb

        //you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
        let base = probex - _g.b2cx;
        let height = _g.biy - probey;

        let distanceFromCentre = Math.sqrt(Math.pow(base, 2) + Math.pow(height, 2));

        if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
            found = true;
            zone = 9;
        }

    } else if (pointIsInBox(probex, probey, _g.b2rox, _g.biy, _g.b2rix, _g.boy)) { //check zone 10
        found = true;
        zone = 10;

    } else if (pointIsInBox(probex, probey, _g.b2rix, _g.biy, _g.rox, _g.boy)) { //check zone 11
        found = true;
        zone = 11;

    } else if (pointIsInBox(probex, probey, _g.rix, _g.toy, _g.rox, _g.biy)) { //check zone 12
        found = true;
        zone = 12;

    } else if (pointIsInBox(probex, probey, _g.crx, _g.toy, _g.rix, _g.tiy)) { //check zone 13
        found = true;
        zone = 13;

    }

    if (!found) {
        zone = -1;
    }

    return zone;
}

//check if a point (xin, yin) is in a box bounded by top left and bottom right coords
function pointIsInBox(xin, yin, tlx, tly, brx, bry) {
    if (xin > tlx && xin < brx && yin > tly && yin < bry) {
        return true;
    } else {
        return false;
    }
}

function displayToNdp(number, n=1) {
	pre = 10**n;
	offset = Math.floor(Math.log10(number || 1));
	if (offset < 0) {
		offset = 0
	}
	//console.log(number, n, offset, pre)
	return (Math.round(number*pre)/pre
		).toPrecision(n+offset+1).toString().slice(0,n+offset+2);
}

function initDraggableItems(context) {

    _g.draggableItems[1] = _g.voltageSlider;
    _g.draggableItems[1].dragId = 'voltageSlider';

    _g.draggableItems[2] = _g.resistanceSlider1;
    _g.draggableItems[2].dragId = 'resistanceSlider1';

    _g.draggableItems[3] = _g.resistanceSlider2;
    _g.draggableItems[3].dragId = 'resistanceSlider2';

    _g.draggableItems[4] = _g.voltmeter;
    _g.draggableItems[4].dragId = 'voltmeter';

    _g.draggableItems[5] = _g.leftProbe;
    _g.draggableItems[5].dragId = 'leftProbe';

    _g.draggableItems[6] = _g.rightProbe;
    _g.draggableItems[6].dragId = 'rightProbe';

    _g.draggableItems[7] = _g.ammeter;
    _g.draggableItems[7].dragId = 'ammeter';

    _g.draggableItems[8] = _g.powerMeter;
    _g.draggableItems[8].dragId = 'powerMeter';

    _g.draggableItems[9] = _g.stopWatch;
    _g.draggableItems[9].dragId = 'stopWatch';

    _g.draggableItems.forEach(function(item, index) {

        context.input.setDraggable(_g.draggableItems[index]);

    });

    //  The pointer has to move 2 pixels before it's considered as a drag
    context.input.dragDistanceThreshold = 16;

    context.input.on('dragstart', function(pointer, gameObject) {

        _g.draggedObject = gameObject;
        _g.dragged = gameObject.dragId;

        _g.draggableItems.forEach(function(item, index) {

            if (_g.draggedObject === _g.draggableItems[index]) {
                _g.draggedIndex = index;
            }

        });

        //For touchscreen
        if (_g.touch) {
            _g.xOffset = pointer.x - _g.draggedObject.x;
            _g.yOffset = pointer.y - _g.draggedObject.y;
        }
      	else {
        	_g.xOffset = 0;
        	_g.yOffset = 0;
        }
        //_g.dragging = true;

    });

    context.input.on('drag', function(pointer, gameObject, dragX, dragY) {

        _g.pointerx = pointer.x;
        _g.pointery = pointer.y;

        _g.dragging = true;

    });

    context.input.on('dragend', function(pointer, gameObject) {

        checkVoltmeterProbes();
        _g.dragging = false;

        handleSnapBack(context);
    });
}

function handleSnapBack(context) {

    if (_g.dragged === 'voltmeter') {

        if (!_g.leftProbe.locked && !_g.rightProbe.locked && _g.draggedObject.x > _g.homeAreaX) {
            //snap back
            _g.draggedObject.x = _g.voltMeterHomeX;
            _g.draggedObject.y = _g.voltMeterHomeY;

            leadSnapBack('left', context);
            leadSnapBack('right', context);

            _g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();
        }

    } else if (_g.dragged === 'ammeter') {

        if (_g.draggedObject.x > _g.homeAreaX) {
            //snap back
            _g.draggedObject.x = _g.ammeterHomeX;
            _g.draggedObject.y = _g.ammeterHomeY;

            _g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
        }

    } else if (_g.dragged === 'powerMeter') {

        if (_g.draggedObject.x > _g.homeAreaX) {
            //snap back
            _g.draggedObject.x = _g.powerMeterHomeX;
            _g.draggedObject.y = _g.powerMeterHomeY;

            _g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
        }

    } else if (_g.dragged === 'stopWatch') {

        if (_g.draggedObject.x > _g.homeAreaX) {
            //snap back
            _g.draggedObject.x = _g.stopWatchHomeX;
            _g.draggedObject.y = _g.stopWatchHomeY;

            _g.startStopButton.x = _g.stopWatch.x + _g.stopWatchStartStopXOffset;
            _g.startStopButton.y = _g.stopWatch.y + _g.stopWatchStartStopYOffset;

            _g.resetButton.x = _g.stopWatch.x + _g.stopWatchResetXOffset;
            _g.resetButton.y = _g.stopWatch.y + _g.stopWatchResetYOffset;

            _g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
        }

    }

    //_g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();

}

function handleVoltageSlider() {
    const maxVoltage = 12;
    const minVoltage = 0;
    const voltageRange = maxVoltage - minVoltage;

    let dragProportion;
    let voltage;

    const leftBound = _g.voltageSliderLeftBound;
    const rightBound = _g.voltageSliderRightBound;
    const dragRange = rightBound - leftBound;

    _g.draggedObject.x = _g.pointerx - _g.xOffset;

    if (_g.draggedObject.x < leftBound) {
        _g.draggedObject.x = leftBound;
    }

    if (_g.draggedObject.x > rightBound) {
        _g.draggedObject.x = rightBound;
    }

    _g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

    dragProportion = (_g.draggedObject.x - leftBound) / dragRange;

    voltage = minVoltage + (dragProportion * voltageRange);
    changeCellVoltage(voltage);

}

function handleResistanceSlider(bulb) {

    const maxResistance = 24;
    const minResistance = 3;
    const resistanceRange = maxResistance - minResistance;

    let dragProportion;
    let resistance;

    let leftBound;
    let rightBound;

    if (bulb === 1) {
        leftBound = _g.resistanceSlider1LeftBound;
        rightBound = _g.resistanceSlider1RightBound;
    } else if (bulb === 2) {
        leftBound = _g.resistanceSlider2LeftBound;
        rightBound = _g.resistanceSlider2RightBound;
    }

    const dragRange = rightBound - leftBound;

    _g.draggedObject.x = _g.pointerx - _g.xOffset;

    if (_g.draggedObject.x < leftBound) {
        _g.draggedObject.x = leftBound;
    }

    if (_g.draggedObject.x > rightBound) {
        _g.draggedObject.x = rightBound;
    }

    _g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

    dragProportion = (_g.draggedObject.x - leftBound) / dragRange;

    resistance = minResistance + (dragProportion * resistanceRange);
    changeBulbResistance(bulb, resistance);

}

function changeCellVoltage(newVoltage) {
    _g.physCellVoltage = newVoltage;

    updatePhysics();
    updateVoltmeter();
    updateAmmeter();
    updatePowerMeter();
}

function changeBulbResistance(bulb, newResistance) {

    if (bulb === 1) {
        _g.physBulb1Resistance = newResistance;
    } else if (bulb === 2) {
        _g.physBulb2Resistance = newResistance;
    }

    updatePhysics();

    checkIfVolmeterNeedsUpdating();

    updateAmmeter();

    updatePowerMeter();
}

function checkIfVolmeterNeedsUpdating() {

    if (_g.leftProbe.locked && _g.rightProbe.locked) {
        _g.leftProbeVoltage = getProbeVoltage('resistance slider', 'left');
        _g.rightProbeVoltage = getProbeVoltage('resistance slider', 'right');

        updateVoltmeter();
    }
}

function expandPowerCircles() {

    const baseSpeed = 10 //set for 6 watts
    let powerSpeed1 = Math.floor(baseSpeed * _g.inputPowerProportion1);
    let powerSpeed2 = Math.floor(baseSpeed * _g.inputPowerProportion2);

    if (powerSpeed1 < 1) {
        powerSpeed1 = 1;
    }

    if (powerSpeed2 < 1) {
        powerSpeed2 = 1;
    }

    _g.powerCircle1[_g.powerCircle1Current].setVisible(false);

    if (_g.showEnergy) {

        if (_g.physCurrent > 0.05) { //don't expand the circle if the current is too low

            if (_g.powerCircle1Current + powerSpeed1 < _g.mapSize - 1) {
                _g.powerCircle1Current += powerSpeed1;

                _g.powerCircle1[_g.powerCircle1Current].setVisible(true);

            } else {
                _g.powerCircle1[_g.powerCircle1Current].setVisible(false);
                _g.powerCircle1Current = 1;
            }
        }
    }

    _g.powerCircle2[_g.powerCircle2Current].setVisible(false);

    if (_g.showEnergy) {

        if (_g.physCurrent > 0.05) { //don't expand the circle if the current is too low

            if (_g.powerCircle2Current + powerSpeed2 < _g.mapSize - 1) {
                _g.powerCircle2Current += powerSpeed2;

                _g.powerCircle2[_g.powerCircle2Current].setVisible(true);

            } else {
                _g.powerCircle2[_g.powerCircle2Current].setVisible(false);
                _g.powerCircle2Current = 1;
            }
        }
    }

}

function moveCharges() {
    let wiggleX = 0;
    let wiggleY = 0;

    for (let i = 1; i <= _g.totalCharges; ++i) {

        _g.energy[i].position += Math.floor(_g.speed * _g.inputCurrentProportion);

        //If the charge is going to hit the rhs of the cell, jump it to the lhs
        if (_g.energy[i].position > _g.totalLoopLength) {
            _g.energy[i].position = _g.energy[i].position - _g.totalLoopLength;
        }

        let currentPosition = _g.energy[i].position;

        let mappedX = _g.elementMap[currentPosition].xMap;
        let mappedY = _g.elementMap[currentPosition].yMap;

        //is a number between 0 and 1
        let scale = _g.potentialMap[currentPosition];

        //add in some wiggle

        //if (Phaser.Math.Between(1, 6) === 4) {
        wiggleX = Phaser.Math.Between(-2, 2);
        wiggleY = Phaser.Math.Between(-2, 2);
        //}

        _g.energy[i].x = mappedX + wiggleX;
        _g.energy[i].y = mappedY + wiggleY;

        _g.charge[i].x = mappedX + wiggleX;
        _g.charge[i].y = mappedY + wiggleY;

        //_g.energy[i].scaleX = scale * Math.sqrt(_g.inputCellVoltageProportion);
        //_g.energy[i].scaleY = scale * Math.sqrt(_g.inputCellVoltageProportion);

        if (_g.showEnergy) {
            _g.energy[i].scaleX = scale * Math.sqrt(_g.inputCellVoltageProportion);
            _g.energy[i].scaleY = scale * Math.sqrt(_g.inputCellVoltageProportion);
        } else {
            _g.energy[i].scaleX = 0;
            _g.energy[i].scaleY = 0;
        }

    }

}

function initPowerCircles(context) {
    _g.powerCircle1 = [];
    _g.powerCircle2 = [];

    _g.powerCircleAlpha = 0;

    _g.powerCircle1Current = 1;
    _g.powerCircle2Current = 1;

    //two phases: 1. inner radius grows slowly, outer expands and fades. 2. Outer radius expands slowly, inner expands quickly
    let alphaStart1 = 0.7;
    let alphaDecrement1 = 0.0035;
    let currentAlpha1 = alphaStart1;

    let thicknessStart1 = 3;
    let thicknessIncrement1 = 0.5;
    let currentThickness1 = thicknessStart1;

    let radiusStart1 = 60;
    let radiusIncrement1 = 0.4;
    let currentRadius1 = radiusStart1;

    _g.mapSize = 200; //must be even, since it's halved and use as the index of an array

    //for location coordinate references see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

    for (var i = 1; i < _g.mapSize / 2; ++i) {
        currentAlpha1 -= alphaDecrement1;
        currentThickness1 += thicknessIncrement1;
        currentRadius1 += radiusIncrement1;

        _g.powerCircle1[i] = context.add.circle(_g.b1cx, _g.biy, currentRadius1);
        _g.powerCircle1[i].setStrokeStyle(currentThickness1, 0xff0000, currentAlpha1);
        _g.powerCircle1[i].setVisible(false);

        _g.powerCircle2[i] = context.add.circle(_g.b2cx, _g.biy, currentRadius1);
        _g.powerCircle2[i].setStrokeStyle(currentThickness1, 0xff0000, currentAlpha1);
        _g.powerCircle2[i].setVisible(false);

    }

    let alphaStart2 = currentAlpha1;
    let alphaDecrement2 = 0.0034;
    let currentAlpha2 = alphaStart2;

    let thicknessStart2 = currentThickness1;

    let thicknessDecrement2 = 0.2;
    let currentThickness2 = thicknessStart2;

    let radiusStart2 = currentRadius1;
    let radiusIncrement2 = 0.5;
    let currentRadius2 = radiusStart2;

    for (var i = _g.mapSize / 2; i <= _g.mapSize; ++i) {
        currentAlpha2 -= alphaDecrement2;
        currentThickness2 -= thicknessDecrement2;
        currentRadius2 += radiusIncrement2;

        _g.powerCircle1[i] = context.add.circle(_g.b1cx, _g.biy, currentRadius2);
        _g.powerCircle1[i].setStrokeStyle(currentThickness2, 0xff0000, currentAlpha2);
        _g.powerCircle1[i].setVisible(false);

        _g.powerCircle2[i] = context.add.circle(_g.b2cx, _g.biy, currentRadius2);
        _g.powerCircle2[i].setStrokeStyle(currentThickness2, 0xff0000, currentAlpha2);
        _g.powerCircle2[i].setVisible(false);

    }
}

function placeCharges(context) {
    let spacingOnElementMap = Math.floor(_g.totalLoopLength / _g.totalCharges);

    let currentPosition = 1;

    for (let i = 1; i <= _g.totalCharges; ++i) {

        let mappedX = _g.elementMap[currentPosition].xMap;
        let mappedY = _g.elementMap[currentPosition].yMap;

        let scale = _g.potentialMap[currentPosition];

        _g.energy[i] = context.add.circle(mappedX, mappedY, 20, 0xff0000);
        _g.energy[i].alpha = 0.5;
        _g.energy[i].scaleX = scale;
        _g.energy[i].scaleY = scale;

        _g.energy[i].position = currentPosition;

        _g.charge[i] = context.add.circle(mappedX, mappedY, 3, 0x000000);

        currentPosition += spacingOnElementMap;

    }

}

function mapPotentials() {
    _g.potentialMap = [];

    let cumTotal = 0;
    const cellVoltageScale = 1;

    const totalResistance = _g.physBulb1Resistance + _g.physBulb2Resistance;

    //calculate the potential proportion between the bulbs so you know how to distribute potential around the two bulbs
    const midPointPotential = cellVoltageScale - (_g.physBulb1Resistance / totalResistance);
    const bulb1pd = _g.physBulb1Resistance / totalResistance;
    const bulb2pd = _g.physBulb2Resistance / totalResistance;

    //make available for the getProbeVoltage function
    _g.midPointPotential = midPointPotential;
    _g.bulb1pd = bulb1pd;
    _g.bulb2pd = bulb2pd;

    //working round the circuit anticlockwise from the left side of the cell
    // for labelling conventions see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

    //left of cell to beginning of left bulb little vertical rise
    for (let i = cumTotal; i < (cumTotal + _g.l1 + _g.l2 + _g.l3) * _g.mapMult; ++i) {
        _g.potentialMap[i] = cellVoltageScale;
    }

    cumTotal += (_g.l1 + _g.l2 + _g.l3) * _g.mapMult;

    //round the left bulb including the two little vertical joins
    let distanceRound = 0;
    let proportion;

    const bulbTravel = (_g.l4 + _g.l5 + _g.l6) * _g.mapMult;

    for (let i = cumTotal; i < cumTotal + bulbTravel; ++i) {
        proportion = distanceRound / bulbTravel;
        _g.potentialMap[i] = Math.sqrt(cellVoltageScale - (proportion * bulb1pd));

        distanceRound += 1;
    }

    cumTotal += bulbTravel; //bulb travel already has * g.mapMult in it

    //across the bottom between the two bulb little verticals
    for (let i = cumTotal; i < (cumTotal + _g.l7) * _g.mapMult; ++i) {
        _g.potentialMap[i] = Math.sqrt(midPointPotential);
    }

    cumTotal += _g.l7 * _g.mapMult;

    //round the right bulb including the two little vertical joins
    distanceRound = 0;

    for (let i = cumTotal; i < cumTotal + bulbTravel; ++i) {
        proportion = distanceRound / bulbTravel;
        _g.potentialMap[i] = Math.sqrt(midPointPotential - (proportion * bulb2pd));

        distanceRound += 1;
    }

    cumTotal += bulbTravel; //bulb travel already has * g.mapMult in it

    //from the right side of the bulb to the right side of the cell
    for (let i = cumTotal; i <= (cumTotal + _g.l11 + _g.l12 + _g.l13) * _g.mapMult; ++i) {

        _g.potentialMap[i] = 0;
    }

    cumTotal += (_g.l11 + _g.l12 + _g.l13) * _g.mapMult;

}

function initPhysics() {

    //These are so you have something to compare the speed of the black dots, the size of the energy circles
    //and the rate of the power circle
    _g.physRefCellVoltage = 6;
    _g.physRefCurrent = 1;
    _g.physRefPower = _g.physRefCellVoltage * _g.physRefCurrent;

    //These define the variables and also set them to starting values for the sliders that will control them
    _g.physCellVoltage = 6;
    _g.physBulb1Resistance = 6;
    _g.physBulb2Resistance = 6;

    _g.physCurrent;

    _g.physPower1;
    _g.physPower2;

    //These are the proportions that are used to control current, energy circles and power circle
    _g.inputCellVoltageProportion = 1;
    _g.inputCurrentProportion = 1;

    updatePhysics();
}

function updatePhysics() {
    _g.physCurrent = _g.physCellVoltage / (_g.physBulb1Resistance + _g.physBulb2Resistance);

    let totalResistance = _g.physBulb1Resistance + _g.physBulb2Resistance;
    let bulb1pd = _g.physCellVoltage * _g.physBulb1Resistance / totalResistance;
    let bulb2pd = _g.physCellVoltage * _g.physBulb2Resistance / totalResistance;

    _g.physPower1 = bulb1pd * _g.physCurrent;
    _g.physPower2 = bulb2pd * _g.physCurrent;

    _g.inputCellVoltageProportion = _g.physCellVoltage / _g.physRefCellVoltage;
    _g.inputCurrentProportion = _g.physCurrent / _g.physRefCurrent;

    _g.inputPowerProportion1 = _g.physPower1 / _g.physRefPower;
    _g.inputPowerProportion2 = _g.physPower2 / _g.physRefPower;

    mapPotentials();
}

function mapElements() {
    _g.elementMap = [];

    let cumTotal = 0;
    let diff = 0; // used to add the difference in i value, not the absolute number;

    //working round the circuit anticlockwise from the left side of the cell
    //for naming see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

    //left of cell to top left corner
    const l1 = _g.clx - _g.mlx;
    for (let i = 1; i < l1 * _g.mapMult; ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.clx - diff,
            yMap: _g.mty
        };
    }

    cumTotal += (l1 * _g.mapMult);

    //topleft corner to bottom left corner
    const l2 = _g.mby - _g.mty;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l2 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mlx,
            yMap: _g.mty + diff
        };
    }

    cumTotal += (l2 * _g.mapMult);

    //bottom left corner to left of left bulb
    const l3 = _g.mb1lx - _g.mlx;

    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l3 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mlx + diff,
            yMap: _g.mby
        };
    }

    cumTotal += (l3 * _g.mapMult);

    //tiny vertical up to the left start of the arc on the lefthand bulb
    const l4 = _g.mby - _g.biy;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l4 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mb1lx,
            yMap: _g.mby - diff
        };
    }

    cumTotal += (l4 * _g.mapMult);

    //round the curve of the lefthand bulb
    let distanceRound = 0;
    const l5 = Math.floor(Math.PI * _g.mr);

    for (let i = cumTotal; i < cumTotal + (l5 * _g.mapMult); ++i) {

        let coords = getCoordsForBulb(distanceRound, l5, _g.mr);

        _g.elementMap[i] = {
            xMap: _g.b1cx - coords.xVal,
            yMap: _g.biy - coords.yVal
        };

        distanceRound += (1 / _g.mapMult);
    }

    cumTotal += (l5 * _g.mapMult);

    //tiny vertical down from the right side of the left bulb curve to the middle of the wire
    const l6 = _g.mby - _g.biy;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l6 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mb1rx,
            yMap: _g.mby - (_g.ww / 2) + diff
        };
    }

    cumTotal += (l6 * _g.mapMult);

    //between bulb 1 and bulb 2
    const l7 = _g.mb2lx - _g.mb1rx;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l7 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mb1rx + diff,
            yMap: _g.mby
        };
    }

    cumTotal += (l7 * _g.mapMult);

    //tiny vertical up to the left start of the arc on the righthand bulb
    const l8 = _g.mby - _g.biy;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l8 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mb2lx,
            yMap: _g.mby - diff
        };
    }

    cumTotal += (l8 * _g.mapMult);

    //round the curve of the righthand bulb
    distanceRound = 0;
    const l9 = Math.floor(Math.PI * _g.mr);

    for (let i = cumTotal; i < cumTotal + (l5 * _g.mapMult); ++i) {

        let coords = getCoordsForBulb(distanceRound, l9, _g.mr);

        _g.elementMap[i] = {
            xMap: _g.b2cx - coords.xVal,
            yMap: _g.biy - coords.yVal
        };

        distanceRound += (1 / _g.mapMult);
    }

    cumTotal += (l9 * _g.mapMult);

    //tiny vertical down from the right side of the right bulb curve to the middle of the wire
    const l10 = _g.mby - _g.biy;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l10 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mb2rx,
            yMap: _g.mby - (_g.ww / 2) + diff
        };
    }

    cumTotal += (l10 * _g.mapMult);


    //right side of righthand bulb to bottom right corner
    const l11 = _g.mrx - _g.mb2rx;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l11 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mb2rx + diff,
            yMap: _g.mby
        };
    }

    cumTotal += (l11 * _g.mapMult);

    //bottom right corner to top right corner
    const l12 = _g.mby - _g.mty;
    diff = 0;
    for (let i = cumTotal; i < cumTotal + (l12 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mrx,
            yMap: _g.mby - diff
        };
    }

    cumTotal += (l12 * _g.mapMult);

    //top right corner to right of cell
    const l13 = _g.mrx - _g.crx;
    diff = 0;
    for (let i = cumTotal; i <= cumTotal + (l13 * _g.mapMult); ++i) {
        diff += (1 / _g.mapMult);
        _g.elementMap[i] = {
            xMap: _g.mrx - diff,
            yMap: _g.mty
        };
    }

    cumTotal += (l13 * _g.mapMult);

    _g.totalLoopLength = cumTotal;

    //make available to the map potentials function
    _g.l1 = l1;
    _g.l2 = l2;
    _g.l3 = l3;
    _g.l4 = l4;
    _g.l5 = l5;
    _g.l6 = l6;
    _g.l7 = l7;
    _g.l8 = l8;
    _g.l9 = l9;
    _g.l10 = l10;
    _g.l11 = l11;
    _g.l12 = l12;
    _g.l13 = l13;

}

function getCoordsForBulb(distance, totalDistance, radius) {
    let proportion = distance / totalDistance;

    let angleDegrees = proportion * 180;
    let angleRadians = angleDegrees * Math.PI / 180;

    return {
        xVal: radius * Math.cos(angleRadians),
        yVal: radius * Math.sin(angleRadians)
    };
}

function createCircuitOutline(context) {

    //variables are defined in a diagram at https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

    const circuitLines = context.add.graphics({
        lineStyle: {
            width: 1,
            color: 0x000000
        }
    });

    const toy = 150;
    const lox = 150;
    const rox = 600;
    const boy = 400;
    const bsr = 30;
    const ww = 25;
    const cw = 15;
    const gr = 80;

    const celllh = ww * 2.8;
    const cellrh = ww * 1.8;

    const mpx = lox + ((rox - lox) / 2);
    const tiy = toy + ww;
    const lix = lox + ww;
    const rix = rox - ww;
    const biy = boy - ww;
    const qiw = (mpx - lix) / 2;
    const b1cx = lix + qiw;
    const b1lox = b1cx - bsr;
    const b1rox = b1cx + bsr;
    const b1lix = b1lox - ww;
    const b1rix = b1rox + ww;
    const blr = bsr + ww;
    const b2cx = rix - qiw;
    const b2lox = b2cx - bsr;
    const b2lix = b2lox - ww;
    const b2rox = b2cx + bsr;
    const b2rix = b2rox + ww;
    const clx = mpx - (cw / 2);
    const crx = clx + cw;

    //draw the outer part of the circuit starting from the cell and moving anticlockwise
    //line IDs are defined in a diagram at https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
    const l1 = new Phaser.Geom.Line(clx, toy, lox, toy);
    const l2 = new Phaser.Geom.Line(lox, toy, lox, boy);
    const l3 = new Phaser.Geom.Line(lox, boy, b1lox, boy);
    const l4 = new Phaser.Geom.Line(b1lox, boy, b1lox, biy);

    const l5 = context.add.graphics();
    l5.lineStyle(1, 0x000000, 1);
    l5.beginPath();
    l5.arc(b1cx, biy, bsr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
    l5.strokePath();

    const l6 = new Phaser.Geom.Line(b1rox, biy, b1rox, boy);
    const l7 = new Phaser.Geom.Line(b1rox, boy, b2lox, boy);
    const l8 = new Phaser.Geom.Line(b2lox, boy, b2lox, biy);

    const l9 = context.add.graphics();
    l9.lineStyle(1, 0x000000, 1);
    l9.beginPath();
    l9.arc(b2cx, biy, bsr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
    l9.strokePath();

    const l10 = new Phaser.Geom.Line(b2rox, biy, b2rox, boy);
    const l11 = new Phaser.Geom.Line(b2rox, boy, rox, boy);
    const l12 = new Phaser.Geom.Line(rox, boy, rox, toy);
    const l13 = new Phaser.Geom.Line(rox, toy, crx, toy);

    circuitLines.strokeLineShape(l1);
    circuitLines.strokeLineShape(l2);
    circuitLines.strokeLineShape(l3);
    circuitLines.strokeLineShape(l4);
    circuitLines.strokeLineShape(l6);
    circuitLines.strokeLineShape(l7);
    circuitLines.strokeLineShape(l8);
    circuitLines.strokeLineShape(l10);
    circuitLines.strokeLineShape(l11);
    circuitLines.strokeLineShape(l12);
    circuitLines.strokeLineShape(l13);

    //draw the inner part of the circuit starting from the cell and moving anticlockwise
    //line IDs are defined in a diagram at https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
    const l14 = new Phaser.Geom.Line(clx, tiy, lix, tiy);
    const l15 = new Phaser.Geom.Line(lix, tiy, lix, biy);
    const l16 = new Phaser.Geom.Line(lix, biy, b1lix, biy);

    const l17 = context.add.graphics();
    l17.lineStyle(1, 0x000000, 1);
    l17.beginPath();
    l17.arc(b1cx, biy, blr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
    l17.strokePath();

    const l18 = new Phaser.Geom.Line(b1rix, biy, b2lix, biy);

    const l19 = context.add.graphics();
    l19.lineStyle(1, 0x000000, 1);
    l19.beginPath();
    l19.arc(b2cx, biy, blr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
    l19.strokePath();

    const l20 = new Phaser.Geom.Line(b2rix, biy, rix, biy);
    const l21 = new Phaser.Geom.Line(rix, biy, rix, tiy);
    const l22 = new Phaser.Geom.Line(rix, tiy, crx, tiy);

    circuitLines.strokeLineShape(l14);
    circuitLines.strokeLineShape(l15);
    circuitLines.strokeLineShape(l16);
    circuitLines.strokeLineShape(l18);
    circuitLines.strokeLineShape(l20);
    circuitLines.strokeLineShape(l21);
    circuitLines.strokeLineShape(l22);

    //top of positive line for cell
    const cellposty = toy + (ww / 2) - (celllh / 2);
    //bottom of positive line for cell
    const cellposby = cellposty + celllh;

    //top of negative thick line for cell
    const cellnegty = toy + (ww / 2) - (cellrh / 2);
    //bottom of negative thick line for cell
    const cellnegby = cellnegty + cellrh;

    //draw the left hand positive (thin) cell line
    const cellpos = new Phaser.Geom.Line(clx, cellposty, clx, cellposby);
    circuitLines.strokeLineShape(cellpos);

    //draw the right hand negative (thick) cell line - it needs a different style
    const negCellLine = context.add.graphics({
        lineStyle: {
            width: 5,
            color: 0x000000
        }
    });
    const cellneg = new Phaser.Geom.Line(crx, cellnegty, crx, cellnegby);
    negCellLine.strokeLineShape(cellneg);

    //draw the two globes around the filament
    const globe1 = new Phaser.Geom.Circle(b1cx, biy, gr);
    const globe2 = new Phaser.Geom.Circle(b2cx, biy, gr);

    const globeGraphics = context.add.graphics({
        lineStyle: {
            width: 1,
            color: 0x000000
        }
    });

    globeGraphics.strokeCircleShape(globe1);
    globeGraphics.strokeCircleShape(globe2);

    // //create some global variables to be used in the mapping function - all values are for the middle of the wire
    // see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

    hw = ww / 2;
    _g.mty = toy + hw;
    _g.mlx = lox + hw;
    _g.mby = biy + hw;
    _g.mrx = rix + hw;
    _g.mr = bsr + hw;
    _g.mb1lx = b1lox - hw;
    _g.mb1rx = b1rox + hw;
    _g.mb2lx = b2lox - hw;
    _g.mb2rx = b2rox + hw;

    _g.b1cx = b1cx;
    _g.b2cx = b2cx;

    _g.clx = clx;
    _g.crx = crx;

    _g.biy = biy;

    _g.ww = ww;

    _g.rox = rox;
    _g.lox = lox;

    _g.blr = blr;
    _g.bsr = bsr;

    _g.b1lix = b1lix;
    _g.b1lox = b1lox;
    _g.b1rix = b1rix;
    _g.b1rox = b1rox;


    _g.b2lix = b2lix;
    _g.b2lox = b2lox;
    _g.b2rix = b2rix;
    _g.b2rox = b2rox;

    _g.toy = toy;
    _g.tiy = tiy;

    _g.lix = lix;
    _g.boy = boy;

    _g.rix = rix;

    _g.bulbTopy = _g.biy - _g.blr;

}

//This is a dev function to help with placement
function createGrid(context) {
    gridLines = context.add.graphics({
        lineStyle: {
            width: 0.2,
            color: 0xafeeee
        }
    });

    const interval = 50;
    let currentLine = 0;
    let line = [];
    let axisValue = [];

    //vertical lines
    for (let xGrid = 0; xGrid < _g.width; xGrid += interval) {
        line[currentLine] = new Phaser.Geom.Line(xGrid, 10, xGrid, _g.height);
        gridLines.strokeLineShape(line[currentLine]);

        axisValue[currentLine] = context.add.text(xGrid - 10, 0, xGrid, {
            fontSize: '15px',
            fill: '#000000'
        });

        currentLine++;
    }

    //horizontal lines
    for (let yGrid = 0; yGrid < _g.height; yGrid += interval) {
        line[currentLine] = new Phaser.Geom.Line(30, yGrid, _g.width, yGrid);
        gridLines.strokeLineShape(line[currentLine]);

        axisValue[currentLine] = context.add.text(0, yGrid - 7, yGrid, {
            fontSize: '15px',
            fill: '#000000'
        });

        currentLine++;
    }
}

const _g = {
    width: 1000,
    height: 550,
};

const config = {
    type: Phaser.AUTO,
    width: _g.width,
    height: _g.height,
    backgroundColor: "f9f9f9",
    physics: {
        default: 'arcade',
        arcade: {
            gravity: {
                y: 0
            },
            enableBody: true,
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);</script>
<title>Physics</title></head><body style="overflow: hidden;"></body></html>
