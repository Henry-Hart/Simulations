<!-- modified from url=(0060)https://furryelephant.com/eton/simple-circuit-iframe-v8.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
<script>
function preload() {
}

function create() {

	_g.tickDelay = 83//ms delay to immitate 12 fps
	_g.totalCharges = 50;
	_g.energy = [];
	_g.charge = [];

	_g.refSpeed = 20; //the speed to give 1 charge per second with a delay of 83 ms for the frame rate
	_g.maxSpeed = 100; //before charges look like they're going backwards at delay of 83 ms for the frame rate
	_g.speed = _g.refSpeed;//has to be a whole number, since you're stepping through an array map

	//used to increase the number of items in the map array by more than the number of pixels round the loop
	//Gives better resolution for wide variety of speeds at higher 'frame rate' as you move around array
	_g.mapMult = 10;
	_g.mapLength;

	_g.powerCircleCurrent = 1;

	_g.draggableItems = [];
	_g.draggedObject;
	_g.draggedIndex;
	_g.dragged;
	_g.dragging = false;

	_g.measuredVoltageProportion = 0;
	_g.voltmeterDisplay = '-.-';

	_g.ammeterOnWire = false;

	_g.showEnergy = true;

	_g.bulbMeasuringPowerFor = 0;

	_g.stopWatchRunning = false;
	_g.stopWatchTime = 0;


	_g.precision = 1
	_g.touch = workOutTouchTickBoxValue();


	//createGrid(this);
	createCircuitOutline(this);
	createVoltageSliderBase(this);
	createVoltageSlider(this);
	createResistanceSliderBase(this);
	createResistanceSlider(this);
	calculateLoopLength();
	mapElements();
	initPhysics();
	mapPotentials();
	placeCharges(this);
	initPowerCircle(this);

	const updateAll = () => {
		moveCharges();
		expandPowerCircle();
		updateStopWatch();
	}

	//instead of update
	_g.update = this.time.addEvent({
	    delay: _g.tickDelay,//this matches the 12 frames per second of the original FE
	    callback: updateAll,
	    callbackScope: this,
	    loop: true,
	});

	initOptionsArea(this);
	initVoltmeterGraphics(this);
	initAmmeterGraphics(this);
	initPowerMeterGraphics(this);
	initTickBoxes(this);//in fact, only one tick box
	initStopWatch(this);


	initDraggableItems(this);
	//need to initialise components first
	if(_g.touch) {handleTick(this, 'touch', 'check');}

	changeCellVoltage(6);
	changeBulbResistance(6);

}

function workOutTouchTickBoxValue() {
  res = getCookie("Touchscreen-c");
  if(res === "1") {
  	return true;
  }
  else if(res === "0"){
    //do nothing
  }
  else { //check if touchscreen
  	if(( 'ontouchstart' in window ) || ( navigator.maxTouchPoints > 0 ) || ( navigator.msMaxTouchPoints > 0 )){
      	//expiry date will only work to 2038 on some browsers...
    	document.cookie = "Touchscreen-c=1;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax";
      	return true;
    }
    else {
    	document.cookie = "Touchscreen-c=0;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax";
    }
  }
  return false;
}

function touchOption(action) {
	if(action === "enable") {
      //expand touch areas
      _g.ammeter.input.hitArea.setSize(60,60);
      _g.ammeter.input.hitArea.centerX = 15;
      _g.ammeter.input.hitArea.centerY = 15;
      //
      _g.voltmeter.input.hitArea.setSize(60,60);
      _g.voltmeter.input.hitArea.centerX = 15;
      _g.voltmeter.input.hitArea.centerY = 15;
      //
      _g.leftProbe.input.hitArea.setSize(30,30);
      _g.leftProbe.input.hitArea.x = -10
      _g.leftProbe.input.hitArea.y = -10
      //
      _g.rightProbe.input.hitArea.setSize(30,30);
      _g.rightProbe.input.hitArea.x = -10
      _g.rightProbe.input.hitArea.y = -10
      //
      _g.powerMeter.input.hitArea.setSize(80,80);
      _g.powerMeter.input.hitArea.centerX = 20;
      _g.powerMeter.input.hitArea.centerY = 20;
      //
      _g.stopWatch.input.hitArea.setSize(100,100)
      _g.stopWatch.input.hitArea.x = 0
      _g.stopWatch.input.hitArea.y = 0
      _g.stopWatch.input.hitArea.centerX = 41; //50-(100-82)/2
      _g.stopWatch.input.hitArea.centerY = 38; //50-(100-76)/2

    }
  	else if(action === "disable") {
      //diminish touch areas
      _g.ammeter.input.hitArea.setSize(30,30);
      _g.ammeter.input.hitArea.centerX = 15;
      _g.ammeter.input.hitArea.centerY = 15;
      //
      _g.voltmeter.input.hitArea.setSize(30,30);
      _g.voltmeter.input.hitArea.centerX = 15;
      _g.voltmeter.input.hitArea.centerY = 15;
      //
      _g.leftProbe.input.hitArea.setSize(15,15);
      _g.leftProbe.input.hitArea.x = 0
      _g.leftProbe.input.hitArea.y = 0
      //
      _g.rightProbe.input.hitArea.setSize(15,15);
      _g.rightProbe.input.hitArea.x = 0
      _g.rightProbe.input.hitArea.y = 0
      //
      _g.powerMeter.input.hitArea.setSize(40,40);
      _g.powerMeter.input.hitArea.centerX = 20;
      _g.powerMeter.input.hitArea.centerY = 20;
      //
      _g.stopWatch.input.hitArea.setSize(82,76)
      //order is important
      _g.stopWatch.input.hitArea.centerX = 50;
      _g.stopWatch.input.hitArea.centerY = 50;
      _g.stopWatch.input.hitArea.x = 0
      _g.stopWatch.input.hitArea.y = 0
  }
}

function getCookie(cname) { //w3schools.com
  var name = cname+"=";
  var ca = document.cookie.split(';');
  for(var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

function initOptionsArea(context){

	const oAX = 815;
	const oAY = 265;

	//const oAX = 770;
	//const oAY = 250;

	const oAWidth = 300;
	const oAHeight = 380;

	_g.homeAreaX = oAX - oAWidth/2;

	const oABox = context.add.rectangle(oAX, oAY, oAWidth, oAHeight, 0xffffff, 1);
	oABox.setStrokeStyle(1, 0x123456, 1);

	const oaHeadingBackground = context.add.rectangle(oAX, oAY - oAHeight/2 + 10, oAWidth, 20, 0x7576B9, 1);
	const heading = context.add.text(oAX - 80, oAY  - oAHeight/2, 'Measurement and display', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.ammeterHomeX = 740;
	_g.ammeterHomeY = 180;

	_g.voltMeterHomeX = 875;
	_g.voltMeterHomeY = _g.ammeterHomeY;

	_g.powerMeterHomeX = _g.ammeterHomeX;
	_g.powerMeterHomeY = 305;

	_g.stopWatchHomeX = _g.voltMeterHomeX;
	_g.stopWatchHomeY = _g.powerMeterHomeY;

	_g.energyTickHomeX = oAX - oAWidth/2 + 40;
	_g.energyTickHomeY = 370;

}

function initTickBoxes(context) {

    _g.tickBoxLeft = _g.energyTickHomeX;
    _g.tickBoxSide = 20;

    _g.tickBoxEnergyY = _g.energyTickHomeY;

    let left = _g.tickBoxLeft;
    let side = _g.tickBoxSide;
    let energyY = _g.tickBoxEnergyY;

    const textX = left + side;
    const textYNudge = side / 2;

    _g.energyTickBox = context.add.rectangle(left, energyY, side, side, 0xffffff, 1);
    _g.energyTickBox.setStrokeStyle(1, 0x123456, 1);

    _g.energyTickBox.setSize(side, side).setInteractive({
        cursor: 'pointer'
    });

    _g.energyTickBox.on('pointerdown', function(pointer) {

        if (_g.showEnergy) {
            _g.showEnergy = false;
            handleTick(context, 'energy', 'uncheck');
        } else {
            _g.showEnergy = true;
            handleTick(context, 'energy', 'check');
        }


    });

    handleTick(context, 'energy', 'check');


    context.add.text(textX, energyY - textYNudge, 'Show energy', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#123456'
    });

    //touchTickBox
  	//energy tick box shifted down 60

    _g.tickBox2Left = _g.energyTickHomeX;

    _g.tickBox2touchY = _g.energyTickHomeY + 60;

    let touchY = _g.tickBox2touchY;

    _g.touchTickBox2 = context.add.rectangle(left, touchY, side, side, 0xffffff, 1);
    _g.touchTickBox2.setStrokeStyle(1, 0x123456, 1);

    _g.touchTickBox2.setSize(side, side).setInteractive({
        cursor: 'pointer'
    });

    _g.touchTickBox2.on('pointerdown', function(pointer) {

        if (_g.touch) {
            _g.touch = false;
            handleTick(context, 'touch', 'uncheck');
        } else {
            _g.touch = true;
            handleTick(context, 'touch', 'check');
        }


    });

    //handleTick(context, 'touch', 'check');

    context.add.text(textX, touchY - textYNudge, 'Touchscreen flexibility', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#123456'
    });

    // could you guess it...
    //precisionTickBox
  	//energy tick box shifted down 30

    touchY -= 30;

    _g.precisionTickBox = context.add.rectangle(left, _g.energyTickHomeY + 30, side, side, 0xffffff, 1);
    _g.precisionTickBox.setStrokeStyle(1, 0x123456, 1);

    _g.precisionTickBox.setSize(side, side).setInteractive({
        cursor: 'pointer'
    });

    _g.precisionTickBox.on('pointerdown', function(pointer) {

      if (_g.precision == 1) {
        _g.precision = 2;
        handleTick(context, 'precision', 'check');
        _g.ammeterOutput.x = -23;
        _g.voltmeterOutput.x = -23;
        _g.powerMeterOutput.x = -22;
      } else {
        _g.precision = 1;
        handleTick(context, 'precision', 'uncheck');
        _g.ammeterOutput.x = -13;
        _g.voltmeterOutput.x = -15;
        _g.powerMeterOutput.x = -12;

      }
      updateAmmeter();
      updateVoltmeter();
      updatePowerMeter();

    });

    //handleTick(context, 'touch', 'check');

    context.add.text(textX, touchY - textYNudge, '2 d.p.', {
        fontFamily: 'Arial',
        fontSize: '15px',
        fill: '#123456'
    });
}

function evalTickParams(left,side,padding) {
    //numbering tick from top left, down to 'v' part and up to top right
    const t1X = left - side / 2 + padding;
    const t1Y = side / 6;

    const t2X = left - side / 6;
    const t2Y = side / 2 - padding;

    const t3X = left + side / 2 - padding;
    const t3Y = side / 2 * -1 + padding;
  	//return
  	return [t1X,t1Y,t2X,t2Y,t3X,t3Y];
}

function handleTick(context, type, action) {
    if (type === 'energy') {
        if (action === 'check') {

          	//vars
            const params = evalTickParams(_g.tickBoxLeft,_g.tickBoxSide,3);
			      let tickY = _g.tickBoxEnergyY;
            //create the energy tick
            _g.energyTick = context.add.graphics();
            _g.energyTick.lineStyle(2, 0x123456);
            _g.energyTick.beginPath();

          	//draw it
            _g.energyTick.moveTo(params[0], tickY + params[1]);
            _g.energyTick.lineTo(params[2], tickY + params[3]);
            _g.energyTick.lineTo(params[4], tickY + params[5]);
            _g.energyTick.strokePath();

        } else if (action === 'uncheck') {

            _g.energyTick.clear();

        }
    } else if (type === 'touch') {
        if (action === 'check') {

          	//vars
          	const params = evalTickParams(_g.tickBoxLeft,_g.tickBoxSide,3);
	          let tickY = _g.tickBoxEnergyY+60

            //create the energy tick
            _g.touchTick = context.add.graphics();
            _g.touchTick.lineStyle(2, 0x123456);
            _g.touchTick.beginPath();

          	//draw it
            _g.touchTick.moveTo(params[0], tickY + params[1]);
            _g.touchTick.lineTo(params[2], tickY + params[3]);
            _g.touchTick.lineTo(params[4], tickY + params[5]);
            _g.touchTick.strokePath();
          	//expand touch areas
			touchOption("enable")
          	//set cookie
         	document.cookie = "Touchscreen-c=1;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax"

        } else if (action === 'uncheck') {

            _g.touchTick.clear();
          	//diminish touch areas
          	touchOption("disable")
          	//set cookie
         	document.cookie = "Touchscreen-c=0;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax"
        }
    } else if (type === 'precision') {
    if (action === "check") {

      const params = evalTickParams(_g.tickBoxLeft,_g.tickBoxSide,3);
      let tickY = _g.tickBoxEnergyY+30
      //create the  tick
      _g.preTick = context.add.graphics();
      _g.preTick.lineStyle(2, 0x123456);
      _g.preTick.beginPath();

      //draw it
      _g.preTick.moveTo(params[0], tickY + params[1]);
      _g.preTick.lineTo(params[2], tickY + params[3]);
      _g.preTick.lineTo(params[4], tickY + params[5]);
      _g.preTick.strokePath();

    } else if (action === 'uncheck') {
      _g.preTick.clear();
    }
  }
}


function createVoltageSliderBase(context) {

	const centrex = 350;
	const centrey = 90;

	_g.voltageSlideBaseCentreY = centrey;

	const width = 300;
	const height = 50;

	const blx = centrex - (width/2);
	const bly = centrey + (height/2);
	const brx = centrex + (width/2);
	const trY = centrey - (height/2);//try is a reserved word

	const padl = 10;
	const padr = padl;
	const padb = 5;

	const divisions = 13;
	const spacing = (width - padl - padr)/(divisions -1);

	const background = context.add.rectangle(centrex , centrey , width, height, 0xD9F8FF);

	const bottomLine = context.add.graphics();
	bottomLine.lineStyle(1, 0x55D4FF);
	bottomLine.beginPath();
	bottomLine.moveTo(blx, bly);
	bottomLine.lineTo(brx, bly);
	bottomLine.strokePath();

	const sideLine = context.add.graphics();
	sideLine.lineStyle(1, 0x55D4FF);
	sideLine.beginPath();
	sideLine.moveTo(brx, bly);
	sideLine.lineTo(brx, trY);
	sideLine.strokePath();

	let currdivx = blx + padl;
	const divby = bly - padb;
	const divHeight = 7;
	const divty = divby - divHeight;

	const fontHeightNudge = 12;
	const singDigitLeftNudge = 4;
	const doubleDigitLeftNudge = 8;
	let leftNudge;
	const valy = divty - padb - fontHeightNudge;

	const div = context.add.graphics();
	div.lineStyle(1, 0x000000);
	div.beginPath();

	for (let i = 1; i <= divisions; i++) {

		//set the left bound for the slider
		if (i === 1) {
			_g.voltageSliderLeftBound = currdivx;
		}

		//set a value for placing the slide in the right place on the scale
		if (i === (divisions + 1)/2) {//find the middle value (i.e. 6 V with 0 V start and 12 V end)
			_g.voltageSliderStartX = currdivx;
		}

		//set the right bound for the slider
		if (i === divisions) {
			_g.voltageSliderRightBound = currdivx;
		}

		div.moveTo(currdivx, divby);
		div.lineTo(currdivx, divty);
		div.strokePath();

		if (i-1 < 10) {
			leftNudge = singDigitLeftNudge;
		} else {
			leftNudge = doubleDigitLeftNudge;
		}

		let value = context.add.text(currdivx - leftNudge, valy, i-1, { fontFamily: 'Arial', fontSize: '14px', fill: '#1C849D' });

		currdivx += spacing;
	}

	const nudgeTitleDown = 4;
	const nudgeTitleRight = 90;

	const title = context.add.text(blx + nudgeTitleRight, trY + nudgeTitleDown, 'Battery voltage (V)', { fontFamily: 'Arial', fontSize: '14px', fill: '#BF292A' });

}

function createVoltageSlider(context) {

	const nudgeDown = 10;

	const centrex = 0;
	const centrey = 0;

	const width = 20;
	const height = 40;

	const blx = centrex - (width/2);
	const bly = centrey + (height/2);
	const brx = centrex + (width/2);
	const trY = centrey - (height/2);//try is a reserved word


	const sliderBackground = context.add.rectangle(0, 0, width, height, 0x000000, 0.1);

	const bottomLine = context.add.graphics();
	bottomLine.lineStyle(1, 0x55D4FF);
	bottomLine.beginPath();
	bottomLine.moveTo(blx, bly);
	bottomLine.lineTo(brx, bly);
	bottomLine.strokePath();

	const rightLine = context.add.graphics();
	rightLine.lineStyle(1, 0x55D4FF);
	rightLine.beginPath();
	rightLine.moveTo(brx, bly);
	rightLine.lineTo(brx, trY);
	rightLine.strokePath();

	const topLine = context.add.graphics();
	topLine.lineStyle(1, 0xffffff);
	topLine.beginPath();
	topLine.moveTo(blx, trY);
	topLine.lineTo(brx, trY);
	topLine.strokePath();

	const leftLine = context.add.graphics();
	leftLine.lineStyle(1, 0xffffff);
	leftLine.beginPath();
	leftLine.moveTo(blx, bly);
	leftLine.lineTo(blx, trY);
	leftLine.strokePath();

	const markerLine = context.add.graphics();
	markerLine.lineStyle(1, 0xBF292A);
	markerLine.beginPath();
	markerLine.moveTo(centrex, bly);
	markerLine.lineTo(centrex, trY);
	markerLine.strokePath();

	_g.voltageSlider = context.add.container(_g.voltageSliderStartX, _g.voltageSlideBaseCentreY + nudgeDown, [sliderBackground, bottomLine, rightLine, topLine, leftLine, markerLine ]);

	//setSize sets hit area for interactive
	_g.voltageSlider.setSize(width, height).setInteractive( { cursor: 'pointer' } );

}

function createResistanceSliderBase(context) {

	const centrex = 350;
	const centrey = 500;

	_g.resistanceSlideBaseCentreY = centrey;

	const width = 300;
	const height = 50;

	const blx = centrex - (width/2);
	const bly = centrey + (height/2);
	const brx = centrex + (width/2);
	const trY = centrey - (height/2);//try is a reserved word

	const padl = 10;
	const padr = padl;
	const padb = 5;

	const scaleStart = 3;
	const scaleEnd = 24;
	const divisions = scaleEnd - scaleStart + 1; //resistance range 3 - 24, so 22 values
	const spacing = (width - padl - padr)/(divisions -1);

	const background = context.add.rectangle(centrex , centrey , width, height, 0xD9F8FF);

	const bottomLine = context.add.graphics();
	bottomLine.lineStyle(1, 0x55D4FF);
	bottomLine.beginPath();
	bottomLine.moveTo(blx, bly);
	bottomLine.lineTo(brx, bly);
	bottomLine.strokePath();

	const sideLine = context.add.graphics();
	sideLine.lineStyle(1, 0x55D4FF);
	sideLine.beginPath();
	sideLine.moveTo(brx, bly);
	sideLine.lineTo(brx, trY);
	sideLine.strokePath();

	let currdivx = blx + padl;
	const divby = bly - padb;
	const divHeight = 7;
	const divty = divby - divHeight;

	const fontHeightNudge = 12;
	const singDigitLeftNudge = 4;
	const doubleDigitLeftNudge = 8;
	let leftNudge;
	const valy = divty - padb - fontHeightNudge;

	const startResistance = 6;
	let scaleValue = scaleStart;
	const scaleDisplayInterval = 3;

	const div = context.add.graphics();
	div.lineStyle(1, 0x000000);
	div.beginPath();

	for (let i = 1; i <= divisions; i++) {

		//set the left bound for the slider
		if (i === 1) {
			_g.resistanceSliderLeftBound = currdivx;
		}

		//set a value for placing the slide in the right place on the scale
		if (scaleValue === startResistance) {//find the middle value (i.e. 6 V with 0 V start and 12 V end)
			_g.resistanceSliderStartX = currdivx;
		}

		//set the right bound for the slider
		if (i === divisions) {
			_g.resistanceSliderRightBound = currdivx;
		}

		div.moveTo(currdivx, divby);
		div.lineTo(currdivx, divty);
		div.strokePath();

		if (scaleValue < 10) {
			leftNudge = singDigitLeftNudge;
		} else {
			leftNudge = doubleDigitLeftNudge;
		}

		if (scaleValue % scaleDisplayInterval === 0 ) {
			let value = context.add.text(currdivx - leftNudge, valy, scaleValue, { fontFamily: 'Arial', fontSize: '14px', fill: '#1C849D' });
		}

		currdivx += spacing;
		scaleValue ++;
	}

	const nudgeTitleDown = 4;
	const nudgeTitleRight = 80;

	const title = context.add.text(blx + nudgeTitleRight, trY + nudgeTitleDown, 'Bulb resistance (ohms)', { fontFamily: 'Arial', fontSize: '14px', fill: '#000000' });

}

function createResistanceSlider(context) {

	const nudgeDown = 10;

	const centrex = 0;
	const centrey = 0;

	const width = 20;
	const height = 40;

	const blx = centrex - (width/2);
	const bly = centrey + (height/2);
	const brx = centrex + (width/2);
	const trY = centrey - (height/2);//try is a reserved word


	const sliderBackground = context.add.rectangle(0, 0, width, height, 0x000000, 0.1);

	const bottomLine = context.add.graphics();
	bottomLine.lineStyle(1, 0x55D4FF);
	bottomLine.beginPath();
	bottomLine.moveTo(blx, bly);
	bottomLine.lineTo(brx, bly);
	bottomLine.strokePath();

	const rightLine = context.add.graphics();
	rightLine.lineStyle(1, 0x55D4FF);
	rightLine.beginPath();
	rightLine.moveTo(brx, bly);
	rightLine.lineTo(brx, trY);
	rightLine.strokePath();

	const topLine = context.add.graphics();
	topLine.lineStyle(1, 0xffffff);
	topLine.beginPath();
	topLine.moveTo(blx, trY);
	topLine.lineTo(brx, trY);
	topLine.strokePath();

	const leftLine = context.add.graphics();
	leftLine.lineStyle(1, 0xffffff);
	leftLine.beginPath();
	leftLine.moveTo(blx, bly);
	leftLine.lineTo(blx, trY);
	leftLine.strokePath();

	const markerLine = context.add.graphics();
	markerLine.lineStyle(1, 0xBF292A);
	markerLine.beginPath();
	markerLine.moveTo(centrex, bly);
	markerLine.lineTo(centrex, trY);
	markerLine.strokePath();

	_g.resistanceSlider = context.add.container(_g.resistanceSliderStartX, _g.resistanceSlideBaseCentreY + nudgeDown, [sliderBackground, bottomLine, rightLine, topLine, leftLine, markerLine ]);

	//setSize sets hit area for interactive
	_g.resistanceSlider.setSize(width, height).setInteractive( { cursor: 'pointer' } );

}

function initVoltmeterGraphics(context) {

	const voltmeterShadow = context.add.circle(3 , 3 , 30, 0x000000, 0.1);
	_g.voltmeterBackground = context.add.circle(0 , 0 , 30, 0x00ff00, 0.5);
	const titleBackground = context.add.rectangle(0, -38, 80, 20, 0x000000, 0.5);
	const title = context.add.text(-32, -46, 'Voltmeter', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.voltmeterOutput = context.add.text(-15, -15, '--.-', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });
	const unitDisplay = context.add.text(-17, 10, 'VOLTS', { fontFamily: 'Arial', fontSize: '10px', fill: '#000000' });

	_g.leftConnection = context.add.circle(-33, 0, 6, 0x000000);
	_g.rightConnection = context.add.circle(33, 0, 6, 0x000000);

	_g.leftLeadHome = { startx: -30, starty: 0, endx: -60, endy: 0 };
	_g.rightLeadHome = { startx: 30, starty: 0, endx: 60, endy: 0 };

	_g.leftProbe = context.add.circle(0, 0, 15, 0xaaaaaa).setInteractive( { cursor: 'pointer' } );
	_g.rightProbe = context.add.circle(0, 0, 15, 0xaaaaaa).setInteractive( { cursor: 'pointer' } );

	_g.rightProbeVoltage = -1;//these are the 'not on a wire' defaults
	_g.leftProbeVoltage = -1;

	_g.leftProbe.locked = false;
	_g.rightProbe.locked = false;

	_g.rightLead = context.add.graphics();
	_g.rightLead.lineStyle(4, 0xff6633);
	_g.rightLead.beginPath();

	_g.leftLead = context.add.graphics();
	_g.leftLead.lineStyle(4, 0xff6633);
	_g.leftLead.beginPath();

	//_g.voltmeterLeftProbe = context.add.circle(-30, 0, 6, 0x000000);

	_g.voltmeter = context.add.container(_g.voltMeterHomeX, _g.voltMeterHomeY, [ voltmeterShadow, _g.voltmeterBackground, _g.leftConnection, _g.rightConnection, titleBackground, title, _g.voltmeterOutput, unitDisplay ]);
	//setSize sets hit area for interactive
	_g.voltmeter.setSize(_g.voltmeterBackground.width, _g.voltmeterBackground.height).setInteractive( { cursor: 'pointer' } );
	_g.voltmeter.setDepth(1);

	leadSnapBack('left', context);
	leadSnapBack('right', context);

}

function leadSnapBack(lead, context) {

	let vm = _g.voltmeter;

	if(lead === 'left') {

		_g.leftLead.clear();
		_g.leftLead.lineStyle(4, 0xff6633);

		_g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
		_g.leftLead.lineTo(vm.x + _g.leftLeadHome.endx, vm.y + _g.leftLeadHome.endy);
		_g.leftLead.strokePath();

		_g.leftProbe.x = vm.x + _g.leftLeadHome.endx;
		_g.leftProbe.y = vm.y + _g.leftLeadHome.endy;
		_g.leftProbe.bounds = _g.leftProbe.getBounds();

	} else if(lead === 'right') {

		_g.rightLead.clear();
		_g.rightLead.lineStyle(4, 0xff6633);

		_g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
		_g.rightLead.lineTo(vm.x + _g.rightLeadHome.endx, vm.y + _g.rightLeadHome.endy);
		_g.rightLead.strokePath();

		_g.rightProbe.x = vm.x + _g.rightLeadHome.endx;
		_g.rightProbe.y = vm.y + _g.rightLeadHome.endy;
		_g.rightProbe.bounds = _g.rightProbe.getBounds();

	}

}

function initAmmeterGraphics(context) {

	const ammeterShadow = context.add.circle(3 , 3 , 30, 0x000000, 0.1);
	const background = context.add.circle(0 , 0 , 30, 0xFF43FF, 0.8);
	const titleBackground = context.add.rectangle(0, -38, 80, 20, 0e000000, 0.5);
	const title = context.add.text(-32, -46, 'Ammeter', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.ammeterOutput = context.add.text(-13, -15, '-.-', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });
	const unitDisplay = context.add.text(-13, 10, 'AMPS', { fontFamily: 'Arial', fontSize: '10px', fill: '#000000' });

	_g.ammeter = context.add.container(_g.ammeterHomeX, _g.ammeterHomeY, [ ammeterShadow, background, titleBackground, title, _g.ammeterOutput, unitDisplay ]);
	//setSize sets hit area for interactive
	_g.ammeter.setSize(background.width, background.height).setInteractive( { cursor: 'pointer' } );
	_g.ammeter.setDepth(2);

}

function initPowerMeterGraphics(context) {

	const powerMeterShadow = context.add.circle(3 , 3 , 40, 0x000000, 0.1);
	const background = context.add.circle(0 , 0 , 40, 0xffffff, 0.2);
	const titleBackground = context.add.rectangle(3, -38, 100, 20, 0x000000, 0.5);
	const title = context.add.text(-40, -46, 'Power meter', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.powerMeterOutput = context.add.text(-12, -15, '-.-', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });
	const unitDisplay = context.add.text(-13, 10, 'WATTS', { fontFamily: 'Arial', fontSize: '10px', fill: '#000000' });

	_g.powerMeter = context.add.container(_g.powerMeterHomeX, _g.powerMeterHomeY, [ powerMeterShadow, background, titleBackground, title, _g.powerMeterOutput, unitDisplay ]);
	//setSize sets hit area for interactive
	_g.powerMeter.setSize(background.width, background.height).setInteractive( { cursor: 'pointer' } );
	_g.powerMeter.setDepth(4);

}

function initStopWatch(context) {

	const stopWatchX = _g.stopWatchHomeX;
	const stopWatchY = _g.stopWatchHomeY;

	//_g.stopWatchX = stopWatchX;
	//_g.stopWatchY = stopWatchY;

	_g.stopWatchStartStopXOffset = -12;
	_g.stopWatchStartStopYOffset = 22;

	_g.stopWatchResetXOffset = 18;
	_g.stopWatchResetYOffset = 17;

	const shadow = context.add.circle(3 , 3 , 50, 0x000000, 0.1);
	const rim = context.add.circle(0 , 0 , 50, 0xF8C646, 1);
	const face = context.add.circle(0 , 0 , 40, 0xE5AF2B, 1);
	const titleBackground = context.add.rectangle(0, -38, 82, 20, 0x000000, 0.5);
	const title = context.add.text(-34, -46, 'Stopwatch', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });
	const numberBackground = context.add.rectangle(0, -8, 58, 30, 0xEBEEEC, 1);

	_g.stopWatchOutput = context.add.text(-16, -23, '0.0', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });

	const unitDisplay = context.add.text(-17, -1, 'SECONDS', { fontFamily: 'Arial', fontSize: '7px', fill: '#000000' });
	_g.stopWatch = context.add.container(stopWatchX, stopWatchY, [ shadow, rim, face, titleBackground, title, numberBackground, _g.stopWatchOutput, unitDisplay ]);

	_g.stopWatch.setSize(82, 76).setInteractive( { cursor: 'pointer' } );
	_g.stopWatch.setDepth(10);

	const startStopRim = context.add.circle(0 , 0 , 12, 0xCF2037, 1);
	const startStopSurface = context.add.circle(0 , 0 , 10, 0xF5626C, 1);
	_g.startStopButton = context.add.container(stopWatchX + _g.stopWatchStartStopXOffset, stopWatchY + _g.stopWatchStartStopYOffset, [ startStopRim, startStopSurface ]);
	_g.startStopButton.setSize(30, 30).setInteractive( { cursor: 'pointer' } );
	_g.startStopButton.setDepth(11);

	_g.startStopButton.on('pointerdown', function () {

		if (_g.stopWatchRunning) {
			_g.stopWatchRunning = false;
		} else {
			_g.stopWatchRunning = true;
		}

	});

	const resetBackground = context.add.rectangle(0, 0, 20, 12, 0x4F4F46, 1);
	const resetSurface = context.add.rectangle(0, 0, 18, 10, 0xB2A4A2, 1);
	_g.resetButton = context.add.container(stopWatchX + _g.stopWatchResetXOffset, stopWatchY + _g.stopWatchResetYOffset, [ resetBackground, resetSurface ]);
	_g.resetButton.setSize(20, 12).setInteractive( { cursor: 'pointer' } );
	_g.resetButton.setDepth(11);

	_g.resetButton.on('pointerdown', function () {

		_g.stopWatchRunning = false;
		resetStopWatch();

	});

	_g.stopWatchIncrement = _g.tickDelay/1000;
	_g.stopWatchSingleDigit = _g.stopWatchOutput.x;

}

function updateStopWatch() {

	const doubleDigitNudge = 7;// moves display left when double digit seconds

	if (_g.stopWatchRunning) {
		_g.stopWatchTime += _g.stopWatchIncrement;

		if (_g.stopWatchTime > 60) {
			resetStopWatch();
		} else if (_g.stopWatchTime >= 10) {
			_g.stopWatchOutput.x = _g.stopWatchSingleDigit - doubleDigitNudge;
		} else {
			_g.stopWatchOutput.x = _g.stopWatchSingleDigit;
		}

		let roundedTime = displayToNdp(_g.stopWatchTime,1);

		_g.stopWatchOutput.setText(roundedTime);
	}

}

function resetStopWatch() {
	_g.stopWatchTime = 0;
	_g.stopWatchOutput.x = _g.stopWatchSingleDigit;
	_g.stopWatchOutput.setText('0.0');
}

function update() {
	if(_g.dragging) {

		if(_g.dragged === 'voltageSlider') {
			handleVoltageSlider();
		} else if (_g.dragged === 'resistanceSlider') {
			handleResistanceSlider();
		} else if (_g.dragged === 'leftProbe') {
			handleDragLeftProbe(this);
		} else if (_g.dragged === 'rightProbe') {
			handleDragRightProbe(this);
		} else if (_g.dragged === 'voltmeter') {
			dragVoltmeter();
		} else if (_g.dragged === 'ammeter') {
			dragAmmeter();
		} else if (_g.dragged === 'powerMeter') {
			dragPowerMeter();
		} else if (_g.dragged === 'stopWatch') {
			dragStopWatch();
		}
	}
}

function handleDragLeftProbe(context) {

	let vm = _g.voltmeter;

	_g.leftProbe.x = vm.x + _g.leftLeadHome.endx;
	_g.leftProbe.y = vm.y + _g.leftLeadHome.endy;
	_g.leftProbe.bounds = _g.leftProbe.getBounds();

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

	_g.leftLead.clear();
	_g.leftLead.lineStyle(4, 0xff6633);

	_g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
	_g.leftLead.lineTo(_g.draggedObject.x, _g.draggedObject.y);
	_g.leftLead.strokePath();

	_g.leftProbeVoltage = getProbeVoltage(context);

	updateVoltmeter();
}


function handleDragRightProbe(context) {

	let vm = _g.voltmeter;

	_g.rightProbe.x = vm.x + _g.rightLeadHome.endx;
	_g.rightProbe.y = vm.y + _g.rightLeadHome.endy;
	_g.rightProbe.bounds = _g.rightProbe.getBounds();

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

	_g.rightLead.clear();
	_g.rightLead.lineStyle(4, 0xff6633);

	_g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
	_g.rightLead.lineTo(_g.draggedObject.x, _g.draggedObject.y);
	_g.rightLead.strokePath();

	_g.rightProbeVoltage = getProbeVoltage(context);

	updateVoltmeter();
}

//if the voltmeter is dragged while the lead is on a wire, keep it where it is
function updateLeadWhileLocked(probe) {

	let vm = _g.voltmeter;

	if (probe === 'left') {

		_g.leftLead.clear();
		_g.leftLead.lineStyle(4, 0xff6633);

		_g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
		_g.leftLead.lineTo(_g.leftProbe.x, _g.leftProbe.y);
		_g.leftLead.strokePath();

	} else if (probe === 'right') {

		_g.rightLead.clear();
		_g.rightLead.lineStyle(4, 0xff6633);

		_g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
		_g.rightLead.lineTo(_g.rightProbe.x, _g.rightProbe.y);
		_g.rightLead.strokePath();

	}
}

function checkVoltmeterProbes() {

	if (_g.rightProbeVoltage != -1) {
		_g.rightProbe.locked = true;
	} else {
		_g.rightProbe.locked = false;
		leadSnapBack('right');
	}

	if (_g.leftProbeVoltage != -1) {
		_g.leftProbe.locked = true;
	} else {
		_g.leftProbe.locked = false;
		leadSnapBack('left');
	}

	updateVoltmeter();
}


function dragVoltmeter () {


	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;


	if(_g.leftProbe.locked) {
		updateLeadWhileLocked('left');
	} else {
		leadSnapBack('left');
	}

	if(_g.rightProbe.locked) {
		updateLeadWhileLocked('right');
	} else {
		leadSnapBack('right');
	}

	_g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();
}

function dragAmmeter() {
	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	let zone = getAmmeterCurrent();//-1 if ammeter is not on wire

	if (zone != -1) {
		_g.ammeterOnWire = true;
	} else {
		_g.ammeterOnWire = false;
	}

	updateAmmeter();

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
}

function dragStopWatch (){

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.startStopButton.x = _g.stopWatch.x + _g.stopWatchStartStopXOffset;
	_g.startStopButton.y = _g.stopWatch.y + _g.stopWatchStartStopYOffset;

	_g.resetButton.x = _g.stopWatch.x + _g.stopWatchResetXOffset;
	_g.resetButton.y = _g.stopWatch.y + _g.stopWatchResetYOffset;

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();

}

function dragPowerMeter(){

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.bulbMeasuringPowerFor = getBulbIDForPower();

	updatePowerMeter();

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
}

function updatePowerMeter() {

    let powerMeterDisplay;

    if (_g.bulbMeasuringPowerFor) {
  		if (_g.precision === 2) _g.powerMeterOutput.x = -22;
  		else _g.powerMeterOutput.x = -12;
  		powerMeterDisplay = displayToNdp(_g["physPower"],
  			_g.precision);
  	}
  	else {
  		_g.powerMeterOutput.x = -12;
  		powerMeterDisplay = '-.-';
  	}

    _g.powerMeterOutput.setText(powerMeterDisplay);


}

function getBulbIDForPower() {

	let found = false;

	let probex = _g.draggedObject.x;
	let probey = _g.draggedObject.y;

	let bulb;

	//there is only one bulb in this circuit but it's written test for several bulbs

	if (pointIsInBox(probex, probey, _g.bilx, _g.bity, _g.birx, _g.briy)) {

		found = true;
		bulb = 1;

	} else {
		found = false;
		bulb = 0
	}

	return bulb;

}

function getProbeVoltage(context) {

	let found = false;

	let probex = _g.draggedObject.x;
	let probey = _g.draggedObject.y;

	let zone;

	let distanceRoundBulb = Math.PI * (_g.bbr - _g.bsr);//measure around the middle of the wire
	let nearBulbLength = (_g.tlix - _g.tlox)/2;//half the wire thickness
	let bulbPdLength = nearBulbLength + distanceRoundBulb + nearBulbLength;

	//for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

	if (pointIsInBox(probex, probey, _g.tlox, _g.tloy, _g.clx, _g.tliy)) { 	//check zone 1
		found = true;
		zone = 1;
		_g.measuredVoltageProportion = 1;
	} else if (pointIsInBox(probex, probey, _g.tlox, _g.tliy, _g.tlix, _g.broy)) {	//check zone 2
		found = true;
		zone = 2;
		_g.measuredVoltageProportion = 1;
	} else if (pointIsInBox(probex, probey, _g.tlix, _g.briy, _g.bilx, _g.broy)) {	//check zone 3
		found = true;
		zone = 3;
		_g.measuredVoltageProportion = 1;
	} else if (pointIsInBox(probex, probey, _g.bilx, _g.briy, _g.bolx, _g.broy)) {	//check zone 4
		found = true;
		zone = 4;

		//As you go up from the middle of the wire upwards towards the beginning of the curve, the potential drops
		let startY = _g.broy - ((_g.broy - _g.briy)/2);//convoluted way of saying half a wire thickness from the bottom

		if (probey < startY) {//only reduce potential above midline
			_g.measuredVoltageProportion = 1 - ((startY - probey)/bulbPdLength);
		} else {
			_g.measuredVoltageProportion = 1;
		}


	} else if (pointIsInBox(probex, probey, _g.bilx, _g.bity, _g.birx, _g.briy)) {	//check zone 5 - bulb

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.mpx;
		let height = _g.briy - probey;

		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.bbr) {
			found = true;
			zone = 5;

			//get the angle of the pointer with the centre of the curve - use cos to get the full angle range from Pi to -Pi
			//subtract this from Pi so the distance from the start begins at 0, not Pi
			let pointerAngleRadians = Math.acos(base/distanceFromCentre);

			let distanceFromCurveStart = (Math.PI - pointerAngleRadians) * (_g.bbr - _g.bsr);
			_g.measuredVoltageProportion = 1 - ((nearBulbLength + distanceFromCurveStart)/bulbPdLength);
		}

	} else if (pointIsInBox(probex, probey, _g.borx, _g.briy, _g.birx, _g.broy)) {	//check zone 6
		found = true;
		zone = 6;

		//As you go up from the top of the wire downwards towards the middle, the potential drops
		//let startY = _g.broy - ((_g.broy - _g.briy)/2);//convoluted way of saying half a wire thickness from the bottom
		let startY = _g.briy;

		if (probey < _g.broy - ((_g.broy - _g.briy)/2)) {//only reduce potential above midline
			_g.measuredVoltageProportion = 1 - ((nearBulbLength + distanceRoundBulb + (probey - startY))/bulbPdLength);
		} else {
			_g.measuredVoltageProportion = 0;
		}

	} else if (pointIsInBox(probex, probey, _g.birx, _g.briy, _g.brox, _g.broy)) {	//check zone 7
		found = true;
		zone = 7;
		_g.measuredVoltageProportion = 0;
	} else if (pointIsInBox(probex, probey, _g.brix, _g.tloy, _g.brox, _g.briy)) {	//check zone 8
		found = true;
		zone = 8;
		_g.measuredVoltageProportion = 0;
	} else if (pointIsInBox(probex, probey, _g.crx, _g.tloy, _g.brix, _g.tliy)) {	//check zone 9
		found = true;
		zone = 9;
		_g.measuredVoltageProportion = 0;
	}

	if(found) {
		return _g.measuredVoltageProportion;
		//updateVoltmeter();
	} else {
		return -1;
	}
}

function updateVoltmeter() {

  let pdProportion; // independent of battery voltage

  if(_g.leftProbeVoltage === -1 || _g.rightProbeVoltage === -1) {
    _g.voltmeterOutput.x = -15;
    _g.voltmeterDisplay = '--.-';
    _g.voltmeterOutput.setText(_g.voltmeterDisplay);
  } else {
    pdProportion = Math.abs(_g.leftProbeVoltage - _g.rightProbeVoltage);

    // need to do this first
    _g.voltmeterDisplay = displayToNdp(_g.physCellVoltage * pdProportion,
      _g.precision);
    _g.voltmeterOutput.setText(_g.voltmeterDisplay);

    // sort out alignment of text based on value
    if (_g.precision === 2) {
      if(_g.voltmeterDisplay.length === 4) _g.voltmeterOutput.x = -23;
      else _g.voltmeterOutput.x = -31;
    }
    else {
      if(_g.voltmeterDisplay.length === 3) _g.voltmeterOutput.x = -17;
      else _g.voltmeterOutput.x = -23;
    }
  }

}

function updateAmmeter() {

  if (_g.ammeterOnWire) {

    if (_g.precision === 2) _g.ammeterOutput.x = -23;
    else _g.ammeterOutput.x = -13;
    _g.ammeterDisplay = displayToNdp(_g.physCurrent, _g.precision);
  } else {
    _g.ammeterOutput.x = -13;
    _g.ammeterDisplay = '-.-';
  }

  _g.ammeterOutput.setText(_g.ammeterDisplay);
}

function getAmmeterCurrent() {

	let found = false;

	let probex = _g.draggedObject.x;
	let probey = _g.draggedObject.y;

	let zone;

	let distanceRoundBulb = Math.PI * (_g.bbr - _g.bsr);//measure around the middle of the wire
	let nearBulbLength = (_g.tlix - _g.tlox)/2;//half the wire thickness
	let bulbPdLength = nearBulbLength + distanceRoundBulb + nearBulbLength;

	//for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

	if (pointIsInBox(probex, probey, _g.tlox, _g.tloy, _g.clx, _g.tliy)) { 	//check zone 1
		found = true;
		zone = 1;
	} else if (pointIsInBox(probex, probey, _g.tlox, _g.tliy, _g.tlix, _g.broy)) {	//check zone 2
		found = true;
		zone = 2;
	} else if (pointIsInBox(probex, probey, _g.tlix, _g.briy, _g.bilx, _g.broy)) {	//check zone 3
		found = true;
		zone = 3;
	} else if (pointIsInBox(probex, probey, _g.bilx, _g.briy, _g.bolx, _g.broy)) {	//check zone 4
		found = true;
		zone = 4;
	} else if (pointIsInBox(probex, probey, _g.bilx, _g.bity, _g.birx, _g.briy)) {	//check zone 5 - bulb

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.mpx;
		let height = _g.briy - probey;

		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.bbr) {
			found = true;
			zone = 5;
		}

	} else if (pointIsInBox(probex, probey, _g.borx, _g.briy, _g.birx, _g.broy)) {	//check zone 6
		found = true;
		zone = 6;
	} else if (pointIsInBox(probex, probey, _g.birx, _g.briy, _g.brox, _g.broy)) {	//check zone 7
		found = true;
		zone = 7;
	} else if (pointIsInBox(probex, probey, _g.brix, _g.tloy, _g.brox, _g.briy)) {	//check zone 8
		found = true;
		zone = 8;
	} else if (pointIsInBox(probex, probey, _g.crx, _g.tloy, _g.brix, _g.tliy)) {	//check zone 9
		found = true;
		zone = 9;
	}

	if(!found) {
		zone = -1;
	}

	return zone;
}

function pointIsInBox(xin, yin, tlx, tly, brx, bry){
	if (xin > tlx && xin < brx && yin > tly && yin < bry) {
		return true;
	} else {
		return false;
	}
}

function displayToNdp(number, n=1) {
	pre = 10**n;
	offset = Math.floor(Math.log10(number || 1));
	if (offset < 0) {
		offset = 0
	}
	//console.log(number, n, offset, pre)
	return (Math.round(number*pre)/pre
		).toPrecision(n+offset+1).toString().slice(0,n+offset+2);
}

function initDraggableItems(context) {

	//_g.voltageSlider = context.add.rectangle(500 , 100 , 20, 40, 0x00ff00).setInteractive( { cursor: 'pointer' } );
	//_g.resistanceSlider = context.add.rectangle(350 , 450 , 20, 40, 0x00ff00).setInteractive( { cursor: 'pointer' } );

	_g.draggableItems[1] = _g.voltageSlider;
	_g.draggableItems[1].dragId = 'voltageSlider';

	_g.draggableItems[2] = _g.resistanceSlider;
	_g.draggableItems[2].dragId = 'resistanceSlider';

	_g.draggableItems[3] = _g.voltmeter;
	_g.draggableItems[3].dragId = 'voltmeter';

	_g.draggableItems[4] = _g.leftProbe;
	_g.draggableItems[4].dragId = 'leftProbe';

	_g.draggableItems[5] = _g.rightProbe;
	_g.draggableItems[5].dragId = 'rightProbe';

	_g.draggableItems[6] = _g.ammeter;
	_g.draggableItems[6].dragId = 'ammeter';

	_g.draggableItems[7] = _g.powerMeter;
	_g.draggableItems[7].dragId = 'powerMeter';

	_g.draggableItems[8] = _g.stopWatch;
	_g.draggableItems[8].dragId = 'stopWatch';

	_g.draggableItems.forEach(function (item, index) {

		context.input.setDraggable(_g.draggableItems[index]);

	});

    //  The pointer has to move 2 pixels before it's considered as a drag
    context.input.dragDistanceThreshold = 2;

		context.input.on('dragstart', function(pointer, gameObject) {

        _g.draggedObject = gameObject;
        _g.dragged = gameObject.dragId;

        _g.draggableItems.forEach(function(item, index) {

            if (_g.draggedObject === _g.draggableItems[index]) {
                _g.draggedIndex = index;
            }

        });

        //For touchscreen
        if (_g.touch) {
            _g.xOffset = pointer.x - _g.draggedObject.x;
            _g.yOffset = pointer.y - _g.draggedObject.y;
        }
      	else {
        	_g.xOffset = 0;
        	_g.yOffset = 0;
        }
        //_g.dragging = true;

    });

    context.input.on('drag', function (pointer, gameObject, dragX, dragY) {

		_g.pointerx = pointer.x;
		_g.pointery = pointer.y;

		_g.dragging = true;

    });

  	context.input.on('dragend', function (pointer, gameObject) {

		checkVoltmeterProbes();
		_g.dragging = false;

		handleSnapBack(context);
	});


}

function handleSnapBack(context) {

	if (_g.dragged === 'voltmeter') {

		if (!_g.leftProbe.locked && !_g.rightProbe.locked  && _g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.voltMeterHomeX;
			_g.draggedObject.y = _g.voltMeterHomeY;

			leadSnapBack('left', context);
			leadSnapBack('right', context);

			_g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();
		}

	} else if (_g.dragged === 'ammeter') {

		if (_g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.ammeterHomeX;
			_g.draggedObject.y = _g.ammeterHomeY;

			_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
		}

	} else if (_g.dragged === 'powerMeter') {

		if (_g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.powerMeterHomeX;
			_g.draggedObject.y = _g.powerMeterHomeY;

			_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
		}

	} else if (_g.dragged === 'stopWatch') {

		if (_g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.stopWatchHomeX;
			_g.draggedObject.y = _g.stopWatchHomeY;

			_g.startStopButton.x = _g.stopWatch.x + _g.stopWatchStartStopXOffset;
			_g.startStopButton.y = _g.stopWatch.y + _g.stopWatchStartStopYOffset;

			_g.resetButton.x = _g.stopWatch.x + _g.stopWatchResetXOffset;
			_g.resetButton.y = _g.stopWatch.y + _g.stopWatchResetYOffset;

			_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
		}

	}

	//_g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();

}

function handleVoltageSlider() {
	const maxVoltage = 12;
	const minVoltage = 0;
	const voltageRange = maxVoltage - minVoltage;

	let dragProportion;
	let voltage;

	const leftBound = _g.voltageSliderLeftBound;
	const rightBound = _g.voltageSliderRightBound;
	const dragRange = rightBound - leftBound;

		_g.draggedObject.x = _g.pointerx - _g.xOffset;

		if (_g.draggedObject.x < leftBound) {
			_g.draggedObject.x = leftBound;
		}

		if (_g.draggedObject.x > rightBound) {
			_g.draggedObject.x = rightBound;
		}

		_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

		dragProportion = (_g.draggedObject.x - leftBound) / dragRange;

		voltage = minVoltage + (dragProportion * voltageRange);
		changeCellVoltage(voltage);

}

function handleResistanceSlider() {

	const maxResistance = 24;
	const minResistance = 3;
	const resistanceRange = maxResistance - minResistance;

	let dragProportion;
	let resistance;

	const leftBound = _g.resistanceSliderLeftBound;
	const rightBound = _g.resistanceSliderRightBound;
	const dragRange = rightBound - leftBound;

	_g.draggedObject.x = _g.pointerx - _g.xOffset;

	if (_g.draggedObject.x < leftBound) {
		_g.draggedObject.x = leftBound;
	}

	if (_g.draggedObject.x > rightBound) {
		_g.draggedObject.x = rightBound;
	}

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

	dragProportion = (_g.draggedObject.x - leftBound) / dragRange;

	resistance = minResistance + (dragProportion * resistanceRange);
	changeBulbResistance(resistance);

}

function changeCellVoltage(newVoltage) {
	_g.physCellVoltage = newVoltage;

	updatePhysics();
	updateVoltmeter();
	updateAmmeter();
	updatePowerMeter();
}

function changeBulbResistance(newResistance) {
	_g.physBulbResistance = newResistance;

	updatePhysics();
	updateAmmeter();
	updatePowerMeter();
}

function expandPowerCircle() {

	const baseSpeed = 10//set for 6 watts
	let powerSpeed = Math.floor(baseSpeed * _g.inputPowerProportion);

	if (powerSpeed < 1) {
		powerSpeed = 1;
	}

	_g.powerCircle[_g.powerCircleCurrent].setVisible(false);

	if (_g.showEnergy){

		if(_g.physCurrent > 0.05) {//don't expand the circle if the current is too low

			if (_g.powerCircleCurrent + powerSpeed < _g.mapSize -1) {
				_g.powerCircleCurrent += powerSpeed;

				_g.powerCircle[_g.powerCircleCurrent].setVisible(true);

			} else {
				_g.powerCircle[_g.powerCircleCurrent].setVisible(false);
				_g.powerCircleCurrent = 1;
			}
		}
	}
}

function moveCharges() {
	let wiggleX = 0;
	let wiggleY = 0;

	for (let i = 1; i <= _g.totalCharges; ++i) {

		_g.energy[i].position += Math.floor(_g.speed * _g.inputCurrentProportion);

		//If the charge is going to hit the rhs of the cell, jump it to the lhs
		if (_g.energy[i].position > _g.totalLoopLength) {
			_g.energy[i].position = _g.energy[i].position - _g.totalLoopLength;
		}

		let currentPosition = _g.energy[i].position;

		let mappedX = _g.elementMap[currentPosition].xMap;
		let mappedY = _g.elementMap[currentPosition].yMap;

		//is a number between 0 and 1
		let scale = _g.potentialMap[currentPosition];

		//add in some wiggle

		//if (Phaser.Math.Between(1, 6) === 4) {
			wiggleX = Phaser.Math.Between(-2, 2);
			wiggleY = Phaser.Math.Between(-2, 2);
		//}

		_g.energy[i].x = mappedX + wiggleX;
		_g.energy[i].y = mappedY + wiggleY;

		_g.charge[i].x = mappedX + wiggleX;
		_g.charge[i].y = mappedY + wiggleY;

		if (_g.showEnergy){
	    	_g.energy[i].scaleX = scale * Math.sqrt(_g.inputCellVoltageProportion);
	    	_g.energy[i].scaleY = scale * Math.sqrt(_g.inputCellVoltageProportion);
		} else {
	    	_g.energy[i].scaleX = 0;
	    	_g.energy[i].scaleY = 0;
		}

	}

}

function initPowerCircle(context) {
	_g.powerCircle = [];
	_g.powerCircleAlpha = 0;

	_g.powerCircleCurrent = 1;

	//two phases: 1. inner radius grows slowly, outer expands and fades. 2. Outer radius expands slowly, inner expands quickly
	let alphaStart1 = 0.7;
	let alphaDecrement1 = 0.0035;
	let currentAlpha1 = alphaStart1;

	let thicknessStart1 = 3;
	let thicknessIncrement1 = 0.5;
	let currentThickness1 = thicknessStart1;

	let radiusStart1 = 60;
	let radiusIncrement1 = 0.4;
	let currentRadius1 = radiusStart1;

	_g.mapSize = 200;//must be even, since it's halved and use as the index of an array

	for (var i = 1; i < _g.mapSize / 2; ++i) {
		currentAlpha1 -= alphaDecrement1;
		currentThickness1 += thicknessIncrement1;
		currentRadius1 += radiusIncrement1;

		_g.powerCircle[i] = context.add.circle(_g.bulbCenterx, _g.bulbCentery, currentRadius1);
		_g.powerCircle[i].setStrokeStyle(currentThickness1, 0xff0000, currentAlpha1);
		_g.powerCircle[i].setVisible(false);
	}

	let alphaStart2 = currentAlpha1;
	let alphaDecrement2 = 0.0034;
	let currentAlpha2 = alphaStart2;

	let thicknessStart2 = currentThickness1;

	let thicknessDecrement2 = 0.2;
	let currentThickness2 = thicknessStart2;

	let radiusStart2 = currentRadius1;
	let radiusIncrement2 = 0.5;
	let currentRadius2 = radiusStart2;

	for (var i = _g.mapSize / 2; i <= _g.mapSize; ++i) {
		currentAlpha2 -= alphaDecrement2;
		currentThickness2 -= thicknessDecrement2;
		currentRadius2 += radiusIncrement2;

		_g.powerCircle[i] = context.add.circle(_g.bulbCenterx, _g.bulbCentery, currentRadius2);
		_g.powerCircle[i].setStrokeStyle(currentThickness2, 0xff0000, currentAlpha2);
		_g.powerCircle[i].setVisible(false);
	}
}

function placeCharges(context) {
	let spacingOnElementMap = Math.floor(_g.totalLoopLength/_g.totalCharges);

	let currentPosition = 1;

	for (let i = 1; i <= _g.totalCharges; ++i) {

		let mappedX = _g.elementMap[currentPosition].xMap;
		let mappedY = _g.elementMap[currentPosition].yMap;

		let scale = _g.potentialMap[currentPosition];

    	_g.energy[i] = context.add.circle(mappedX, mappedY, 20, 0xff0000);
    	_g.energy[i].alpha = 0.5;
    	_g.energy[i].scaleX = scale;
    	_g.energy[i].scaleY = scale;

    	_g.energy[i].position = currentPosition;

    	_g.charge[i] = context.add.circle(mappedX, mappedY, 3, 0x000000);

    	currentPosition += spacingOnElementMap;

	}

}

function mapPotentials() {
	_g.potentialMap = [];

	let cumTotal = 0;
	let cellVoltageScale = 1;

	//working round the circuit anticlockwise from the left side of the cell

	//left of cell to beginning of bulb arc - actually the wire
	for (let i = cumTotal; i < (cumTotal + _g.cellToTopLeft + _g.topLeftToBottomLeft + _g.bottomLeftToLeftBulb) * _g.mapMult; ++i){
		_g.potentialMap[i] = cellVoltageScale;
	}

	cumTotal += (_g.cellToTopLeft + _g.topLeftToBottomLeft + _g.bottomLeftToLeftBulb) * _g.mapMult;

	//round the bulb including the two little joins
	let distanceRound = 0;
	let proportion = 1;

	let bulbTravel = (_g.littleJoinLeft + _g.roundBulb + _g.littleJoinRight) * _g.mapMult;

	for (let i = cumTotal; i < cumTotal + bulbTravel; ++i) {
		proportion = (bulbTravel - distanceRound)/bulbTravel;
		_g.potentialMap[i] = Math.sqrt(cellVoltageScale * proportion);

		distanceRound += 1;
	}

	cumTotal += bulbTravel;//bulb travel already has * g.mapMult in it

	//from the right side of the bulb to the right side of the cell
	for (let i = cumTotal; i <= cumTotal + (_g.rightOfBulbToBottomRight + _g.bottomRightToTopRight + _g.topRightToCell) * _g.mapMult; ++i) {

		_g.potentialMap[i] = 0;
	}

	cumTotal += (_g.rightOfBulbToBottomRight + _g.bottomRightToTopRight + _g.topRightToCell) * _g.mapMult;
}

function initPhysics() {

	//These are so you have something to compare the speed of the black dots, the size of the energy circles
	//and the rate of the power circle
	_g.physRefCellVoltage = 6;
	_g.physRefCurrent = 1;
	_g.physRefPower = _g.physRefCellVoltage * _g.physRefCurrent;


	//These define the variables and also set them to starting values for the sliders that will control them
	_g.physCellVoltage = 6;
	_g.physBulbResistance = 6;

	_g.physCurrent;
	_g.physPower;

	//These are the proportions that are used to control current, energy circles and power circle
	_g.inputCellVoltageProportion = 1;
	_g.inputCurrentProportion = 1;
	_g.inputPowerProportion = 1;//not strictly an input

	updatePhysics();
}

function updatePhysics() {
	_g.physCurrent = _g.physCellVoltage/_g.physBulbResistance;
	_g.physPower = _g.physCellVoltage * _g.physCurrent;

	_g.inputCellVoltageProportion = _g.physCellVoltage / _g.physRefCellVoltage;
	_g.inputCurrentProportion = _g.physCurrent / _g.physRefCurrent;
	_g.inputPowerProportion = _g.physPower / _g.physRefPower;
}

function mapElements() {
	_g.elementMap = [];

	let cumTotal = 0;
	let diff = 0; // used to add the difference in i value, not the absolute number;

	//working round the circuit anticlockwise from the left side of the cell

	//left of cell to top left corner
	for (let i = 1; i < _g.cellToTopLeft * _g.mapMult; ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.cellLeftx - diff, yMap: _g.topLefty };
	}

	cumTotal += (_g.cellToTopLeft * _g.mapMult);

	//topleft corner to bottom left corner
	diff = 0;
	for (let i = cumTotal; i < cumTotal + (_g.topLeftToBottomLeft * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.topLeftx, yMap: _g.topLefty + diff };
	}

	cumTotal += (_g.topLeftToBottomLeft * _g.mapMult);

	//bottom left corner to half a wire width away from the inner n of the bulb
	diff = 0;
	for (let i = cumTotal; i < cumTotal + (_g.bottomLeftToLeftBulb * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.bottomLeftx + diff, yMap: _g.bottomLefty };
	}

	cumTotal += (_g.bottomLeftToLeftBulb * _g.mapMult);

	//tiny little half wire thickness up to get inline with the centre point of the bulb
	diff = 0;
	for (let i = cumTotal; i < cumTotal + (_g.littleJoinLeft * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.bulbLeftx, yMap: _g.bulbLefty - diff };
	}

	cumTotal += (_g.littleJoinLeft * _g.mapMult);

	//round the curve of the bulb
	let distanceRound = 0

	for (let i = cumTotal; i < cumTotal + (_g.roundBulb * _g.mapMult); ++i) {

		let coords = getCoordsForBulb(distanceRound, _g.roundBulb, _g.bulbRadius);

		_g.elementMap[i] = { xMap: _g.bulbCenterx - coords.xVal, yMap: _g.bulbCentery - coords.yVal };

		distanceRound += (1 / _g.mapMult);
	}

	cumTotal += (_g.roundBulb * _g.mapMult);

	//tiny little half wire thickness down to get inline with the middle of the bottom wire
	diff = 0;

	for (let i = cumTotal; i < cumTotal + (_g.littleJoinLeft * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.bulbRightx, yMap: _g.bulbRighty - (_g.wireThickness/2) + diff };
	}

	cumTotal += (_g.littleJoinRight * _g.mapMult);

	//right side of bulb to bottom right corner
	diff = 0;
	for (let i = cumTotal; i < cumTotal + (_g.rightOfBulbToBottomRight * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.bulbRightx + diff, yMap: _g.bottomRighty };
	}

	cumTotal += (_g.rightOfBulbToBottomRight * _g.mapMult);

	//bottom right corner to top right corner
	diff = 0;
	for (let i = cumTotal; i < cumTotal + (_g.bottomRightToTopRight * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.bottomRightx, yMap: _g.bottomRighty - diff };
	}

	cumTotal += (_g.bottomRightToTopRight * _g.mapMult);

	//top right corner to right of cell
	diff = 0;
	for (let i = cumTotal; i <= cumTotal + (_g.topRightToCell * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMap[i] = { xMap: _g.topRightx - diff, yMap: _g.topRighty };
	}

	cumTotal += (_g.topRightToCell * _g.mapMult);

	if (cumTotal != _g.totalLoopLength){
		console.log('Paths do not add up');
	}
}

function getCoordsForBulb(distance, totalDistance, radius) {
	let proportion = distance/totalDistance;

	let angleDegrees = proportion * 180;
	let angleRadians = angleDegrees* Math.PI/180;

	return { xVal: radius * Math.cos(angleRadians), yVal: radius * Math.sin(angleRadians)};
}

function calculateLoopLength() {
		_g.cellToTopLeft = Math.floor(_g.cellLeftx - _g.topLeftx);
		_g.topLeftToBottomLeft = Math.floor(_g.bottomLefty - _g.topLefty);
		_g.bottomLeftToLeftBulb = Math.floor(_g.bulbLeftx - _g.bottomLeftx);
		_g.littleJoinLeft = Math.floor(_g.wireThickness/2);
		_g.roundBulb = Math.floor(Math.PI * _g.bulbRadius);
		_g.littleJoinRight = Math.floor(_g.littleJoinLeft);
		_g.rightOfBulbToBottomRight = Math.floor(_g.bottomRightx - _g.bulbRightx);
		_g.bottomRightToTopRight = Math.floor(_g.bottomRighty - _g.topRighty);
		_g.topRightToCell = Math.floor(_g.topRightx - _g.cellRightx);

		_g.totalLoopLength = Math.floor((_g.cellToTopLeft + _g.topLeftToBottomLeft + _g.bottomLeftToLeftBulb + _g.littleJoinLeft + _g.roundBulb + _g.littleJoinRight + _g.rightOfBulbToBottomRight + _g.bottomRightToTopRight + _g.topRightToCell) * _g.mapMult);
}

function createCircuitOutline(context) {
	//console.log('inside createCircuitOutline');

	//Simple circuit with cell and bulb

	//define some points
	//abbreviations: i = inner line; o = outer line; l = left; r = right; t = top; b = bottom;
	//w = width; h = height; d = diameter; r = radius; mp = midpoint; c = centre
	//words: wire; cell; filament; globe

	//wire properties
	const wired = 25;

	//top left outer point
	const tlox = 150;
	const tloy = 150;

	//make available globally see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	_g.tlox = tlox;
	_g.tloy = tloy;

	//bottom right outer point
	const brox = 550;
	const broy = 400;

	//make available globally
	_g.brox = brox;
	_g.broy = broy;

	//mid point x
	const mpx = tlox + ((brox - tlox)/2);

	//make available globally see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	_g.mpx = mpx;

	//bottom left outer point
	const blox = tlox;
	const bloy = broy;

	//top right outer point
	const trox = brox;
	const troy = tloy;

	//top left inner point
	const tlix = tlox + wired;
	const tliy = tloy + wired;

	//make available globally see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	_g.tlix = tlix;
	_g.tliy = tliy;

	//bottom left inner point
	const blix = tlix;
	const bliy = bloy - wired;

	//bottom right inner point
	const brix = brox - wired;
	const briy = bliy;

	//make available globally see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	_g.brix = brix;
	_g.briy = briy;

	//top right inner point
	const trix = brix;
	const triy = tliy;

	//cell properties
	const cellw = 15;
	const celllh = wired * 2.8;
	const cellrh = wired * 1.8;

	//where the positive side of the cell meets the outer and inner wires
	const wirecellolx = mpx - (cellw/2);
	const wirecelloly = tloy;

	const wirecellilx = wirecellolx;
	const wirecellily = tliy;

	//where the negative side of the cell meets the outer and inner wires
	const wirecellorx = mpx + (cellw/2);
	const wirecellory = wirecelloly;

	const wirecellirx = wirecellorx;
	const wirecelliry = tliy;

	//top of positive line for cell
	const cellpostx = wirecellolx;
	const cellposty = wirecelloly + (wired/2) - (celllh/2);

	//bottom of positive line for cell
	const cellposbx = cellpostx;
	const cellposby = cellposty + celllh;

	//top of negative thick line for cell
	const cellnegtx = wirecellorx;
	const cellnegty = wirecellory + (wired/2) - (cellrh/2);

	//bottom of negative thick line for cell
	const cellnegbx = cellnegtx;
	const cellnegby = cellnegty + cellrh;

	//bulb properties - the inner and outer refer to the whole circuit, not the view of the bulb
	const bulbor = 30;

	const bulbcx = mpx;
	const bulbocy = briy;
	const bulbicy = briy;

	const bulbir = bulbor + wired;

	const glober = 80;

	//where the outer meets the left side of the outer (smaller radius) left filament extension
	const wirebulbolx = mpx - bulbor;
	const wirebulboly = bloy;

	//where the inner meets the left side of the inner (larger radius) filament
	const wirebulbilx = mpx - bulbir;
	const wirebulbily = bliy;

	//where the outer meets the right side of the outer (smaller radius) right filament extension
	const wirebulborx = mpx + bulbor;
	const wirebulbory = wirebulboly;

	//where the inner meets the right side of the inner (larger radius) filament
	const wirebulbirx = mpx + bulbir;
	const wirebulbiry = wirebulbily;

	//make available globally see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	_g.bilx = wirebulbilx;
	_g.bolx = wirebulbolx;

	_g.bity = briy - bulbir;
	_g.borx = wirebulborx;
	_g.birx = wirebulbirx;

	_g.clx = cellposbx;
	_g.crx = cellnegtx;

	_g.bbr = bulbir;
	_g.bsr = bulbor;

	const circuitLines = context.add.graphics({ lineStyle: { width: 1, color: 0x000000 } });

	//draw the outer part of the circuit starting from the cell and moving anticlockwise
	const linetol = new Phaser.Geom.Line(tlox, tloy, wirecellolx, wirecelloly);
	const lineol = new Phaser.Geom.Line(tlox, tloy, blox, bloy);
	const linebol = new Phaser.Geom.Line(blox, bloy, wirebulbolx, wirebulboly);
	const linebor = new Phaser.Geom.Line(wirebulborx, wirebulbory, brox, broy);
	const lineor = new Phaser.Geom.Line(brox, broy, trox, troy);
	const linetor = new Phaser.Geom.Line(trox, troy, wirecellorx, wirecellory);

	circuitLines.strokeLineShape(linetol);
	circuitLines.strokeLineShape(lineol);
	circuitLines.strokeLineShape(linebol);
	circuitLines.strokeLineShape(linebor);
	circuitLines.strokeLineShape(lineor);
	circuitLines.strokeLineShape(linetor);

	//draw the inner part of the circuit starting from the cell and moving anticlockwise
	const linetil = new Phaser.Geom.Line(tlix, tliy, wirecellilx, wirecellily);
	const lineil = new Phaser.Geom.Line(tlix, tliy, blix, bliy);
	const linebil = new Phaser.Geom.Line(blix, bliy, wirebulbilx, wirebulbily);
	const linebir = new Phaser.Geom.Line(wirebulbirx, wirebulbiry, brix, briy);
	const lineir = new Phaser.Geom.Line(brix, briy, trix, triy);
	const linetir = new Phaser.Geom.Line(trix, triy, wirecellirx, wirecelliry);

	circuitLines.strokeLineShape(linetil);
	circuitLines.strokeLineShape(lineil);
	circuitLines.strokeLineShape(linebil);
	circuitLines.strokeLineShape(linebir);
	circuitLines.strokeLineShape(lineir);
	circuitLines.strokeLineShape(linetir);

	//draw the outer bulb line (the smaller radius)
	var outerArc = context.add.graphics();
	outerArc.lineStyle(1, 0x000000, 1);
	outerArc.beginPath();
	outerArc.arc(mpx, bulbocy, bulbor, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	outerArc.strokePath();

	//draw the outer bulb line (the smaller radius)
	var innerArc = context.add.graphics();
	innerArc.lineStyle(1, 0x000000, 1);
	innerArc.beginPath();
	innerArc.arc(mpx, bulbicy, bulbir, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	innerArc.strokePath();

	//There's a short straight line at the bottom of the outer filament line (the smaller radius)
	//This extension means the two arcs have the same centre on the inner line

	//draw the two extensions
	const lineextnl = new Phaser.Geom.Line(wirebulbolx, wirebulboly, wirebulbolx, bliy);
	const lineextnr = new Phaser.Geom.Line(wirebulborx, wirebulbory, wirebulborx, bliy);

	circuitLines.strokeLineShape(lineextnl);
	circuitLines.strokeLineShape(lineextnr);

	//draw the left hand positive (thin) cell line
	const cellpos = new Phaser.Geom.Line(cellpostx, cellposty, cellposbx, cellposby);
	circuitLines.strokeLineShape(cellpos);

	//draw the right hand negative (thick) cell line - it needs a different style
	const negCellLine = context.add.graphics({ lineStyle: { width: 5, color: 0x000000 } });
	const cellneg = new Phaser.Geom.Line(cellnegtx, cellnegty, cellnegbx, cellnegby);
	negCellLine.strokeLineShape(cellneg);

	//draw the globe around the filament
	const globe = new Phaser.Geom.Circle(mpx, bulbicy, glober);
	const globeGraphics = context.add.graphics({ lineStyle: { width: 1, color: 0x000000 } });
	globeGraphics.strokeCircleShape(globe);

	//create some global variables to be used in the mapping function - all values are for the middle of the wire
	_g.cellLeftx = wirecellolx;
	_g.cellLefty = wirecelloly + wired/2;

	_g.topLeftx = tlox + wired/2;

	_g.topLefty = tloy + wired/2;

	_g.bottomLeftx = _g.topLeftx;
	_g.bottomLefty = bloy - wired/2;

	_g.bulbLeftx = wirebulbilx + wired/2;
	_g.bulbLefty = _g.bottomLefty;

	_g.bulbCenterx = mpx;
	_g.bulbCentery = bulbocy;
	_g.bulbRadius = bulbor + wired/2;

	_g.bulbRightx = wirebulbirx - wired/2;
	_g.bulbRighty = _g.bulbLefty;

	_g.bottomRightx = brox - wired/2;
	_g.bottomRighty = _g.bottomLefty;

	_g.topRightx = _g.bottomRightx;
	_g.topRighty = _g.topLefty;

	_g.cellRightx = wirecellorx;
	_g.cellRighty = _g.cellLefty;

	_g.wireThickness = wired;

}

//This is a dev function to help with placement
function createGrid(context) {
	gridLines = context.add.graphics({ lineStyle: { width: 0.2, color: 0xafeeee } });

	const interval = 50;
	let currentLine = 0;
	let line = [];
	let axisValue = [];

	//vertical lines
	for (let xGrid =  0; xGrid < _g.width; xGrid += interval) {
		 line[currentLine] = new Phaser.Geom.Line(xGrid, 10, xGrid, _g.height);
		 gridLines.strokeLineShape(line[currentLine]);

		 axisValue[currentLine] = context.add.text(xGrid-10, 0, xGrid, { fontSize: '15px', fill: '#000000' });

		 currentLine++;
	}

	//horizontal lines
	for (let yGrid =  0; yGrid < _g.height; yGrid += interval) {
		 line[currentLine] = new Phaser.Geom.Line(30, yGrid, _g.width, yGrid);
		 gridLines.strokeLineShape(line[currentLine]);

		 axisValue[currentLine] = context.add.text(0, yGrid-7, yGrid, { fontSize: '15px', fill: '#000000' });

		 currentLine++;
	}
}

const _g = {
	width: 1000,
	height: 550,
};

const config = {
	type: Phaser.AUTO,
	width: _g.width,
	height: _g.height,
	backgroundColor: "f9f9f9",
	physics: {
	default: 'arcade',
	arcade: {
		gravity: { y: 0 },
		enableBody: true,
		}
	},
	scene: {
	    preload: preload,
	    create: create,
	    update: update
	}
};

const game = new Phaser.Game(config);
</script></head><body style="overflow: hidden;"></body></html>
