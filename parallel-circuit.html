<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
<script>
function preload() {
}
_this = 0;
function create() {

	_this = this;
	_g.tickDelay = 83//ms delay to immitate 12 fps

	_g.totalCharges = 65;
	_g.energyA = [];
	_g.energyB = [];
	_g.energyC = [];

	_g.chargeA = [];
	_g.chargeB = [];
	_g.chargeC = [];

	_g.refSpeed = 20; //the speed to give 1 charge per second with a delay of 83 ms for the frame rate
	_g.maxSpeed = 100; //before charges look like they're going backwards at delay of 83 ms for the frame rate
	_g.speed = _g.refSpeed; //has to be a whole number, since you're stepping through an array map

	//used to increase the number of items in the map array by more than the number of pixels round the loop
	//Gives better resolution for wide variety of speeds at higher 'frame rate' as you move around array
	_g.mapMult = 10;
	_g.mapLength;

	_g.powerCircleCurrent = 1;

	_g.draggableItems = [];
	_g.draggedObject;
	_g.draggedIndex;
	_g.dragged;
	_g.dragging = false;

	_g.measuredVoltageProportion = 0;
	_g.voltmeterDisplay = '-.-';

	_g.ammeterOnWire = false;

	_g.showEnergy = true;

	_g.bulbMeasuringPowerFor = 0;

	_g.stopWatchRunning = false;
	_g.stopWatchTime = 0;

	// precision
	_g.precision = 1
	// touchscreenyness
	_g.touch = workOutTouchTickBoxValue()

	//createGrid(this);
	createCircuitOutline(this);
	createVoltageSliderBase(this);
	createVoltageSlider(this);
	createResistanceSliderBases(this);
	createResistanceSliders(this);
	mapElements();
	initPhysics();
	mapPotentials();
	placeCharges(this);
	initPowerCircles(this);


	const updateAll = () => {
		moveCharges();
		expandPowerCircles();
		updateStopWatch();
	}

	//instead of update
	_g.update = this.time.addEvent({
	    delay: _g.tickDelay,//this matches the 12 frames per second of the original FE
	    callback: updateAll,
	    callbackScope: this,
	    loop: true,
	});

	initOptionsArea(this, _g.xoffset);
	initVoltmeterGraphics(this);
	initAmmeterGraphics(this);
	initPowerMeterGraphics(this);
	initTickBoxes(this);
	initStopWatch(this);

	initDraggableItems(this);
	//need to initialise components first
	if(_g.touch) {handleTick(this, 'touch', 'check');}
	// changeCellVoltage(6);

}

function initOptionsArea(context, xoffset){

	const oAX = 770 + xoffset;
	const oAY = 265;

	const oAWidth = 300;
	const oAHeight = 380;

	_g.homeAreaX = oAX - oAWidth/2;

	const oABox = context.add.rectangle(oAX, oAY, oAWidth, oAHeight, 0xffffff, 1);
	oABox.setStrokeStyle(1, 0x123456, 1);

	const oaHeadingBackground = context.add.rectangle(oAX, oAY - oAHeight/2 + 10, oAWidth, 20, 0x7576B9, 1);
	const heading = context.add.text(oAX - 80, oAY  - oAHeight/2, 'Measurement and display', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.ammeterHomeX = 695 + xoffset;
	_g.ammeterHomeY = 180;

	_g.voltMeterHomeX = 830 + xoffset;
	_g.voltMeterHomeY = _g.ammeterHomeY;

	_g.powerMeterHomeX = _g.ammeterHomeX;
	_g.powerMeterHomeY = 305;

	_g.stopWatchHomeX = _g.voltMeterHomeX;
	_g.stopWatchHomeY = _g.powerMeterHomeY;

	_g.energyTickHomeX = oAX - oAWidth/2 + 40;
	_g.energyTickHomeY = 370;

}

function initTickBoxes(context) {

	_g.tickBoxLeft = _g.energyTickHomeX;
	_g.tickBoxSide = 20;

	_g.tickBoxEnergyY = _g.energyTickHomeY;

	let left = _g.tickBoxLeft;
	let side = _g.tickBoxSide;
	let energyY = _g.tickBoxEnergyY;

	const textX = left + side;
	const textYNudge = side/2;

	_g.energyTickBox = context.add.rectangle(left, energyY, side, side, 0xffffff, 1);
	_g.energyTickBox.setStrokeStyle(1, 0x123456, 1);

	_g.energyTickBox.setSize(side, side).setInteractive( { cursor: 'pointer' } );

	_g.energyTickBox.on('pointerdown', function (pointer) {
		if (_g.showEnergy) {
			_g.showEnergy = false;
			handleTick(context, 'energy', 'uncheck');
		} else {
			_g.showEnergy = true;
			handleTick(context, 'energy', 'check');
		}
  });

	var shift = 30

	_g.tickBoxLeft2 = _g.energyTickHomeX2;
	_g.tickBoxSide2 = 20;

	_g.tickBoxEnergyY2 = _g.energyTickHomeY2;

	_g.energyTickBox2 = context.add.rectangle(left, energyY+shift, side, side, 0xffffff, 1);
	_g.energyTickBox2.setStrokeStyle(1, 0x123456, 1);

	_g.energyTickBox2.setSize(side, side).setInteractive( { cursor: 'pointer' } );

	_g.energyTickBox2.on('pointerdown', function (pointer) {
		if (_g.precision == 1) {
			_g.precision = 2;
			handleTick(context, 'precision', 'check');
			_g.ammeterOutput.x = -23;
			_g.voltmeterOutput.x = -23;
			_g.powerMeterOutput.x = -22;
		} else {
			_g.precision = 1;
			handleTick(context, 'precision', 'uncheck');
			_g.ammeterOutput.x = -13;
			_g.voltmeterOutput.x = -15;
			_g.powerMeterOutput.x = -12;

		}
		updateAmmeter();
		updateVoltmeter();
		updatePowerMeter();
  });


	//////////////////////

	_g.touchTickBox = context.add.rectangle(left, energyY+shift*2, side, side, 0xffffff, 1);
	_g.touchTickBox.setStrokeStyle(1, 0x123456, 1);

	_g.touchTickBox.setSize(side, side).setInteractive( { cursor: 'pointer' } );

	_g.touchTickBox.on('pointerdown', function (pointer) {
		if (_g.touch == 1) {
			_g.touch = 0;
			handleTick(context, 'touch', 'uncheck');
		} else {
			_g.touch = 1;
			handleTick(context, 'touch', 'check');
  }});

	//////////////////////

	handleTick(context, 'energy', 'check');

	context.add.text(textX, energyY-textYNudge, 'Show energy', { fontFamily: 'Arial', fontSize: '15px', fill: '#123456' });
	context.add.text(textX, energyY-textYNudge+shift, '2 d.p.', { fontFamily: 'Arial', fontSize: '15px', fill: '#123456' });
	context.add.text(textX, energyY-textYNudge+shift*2, 'Touchscreen flexibility', { fontFamily: 'Arial', fontSize: '15px', fill: '#123456' });
}

function handleTick(context, type, action) {
	if (type === 'energy'){
		if (action === 'check') {

			let left = _g.tickBoxLeft;
			let side = _g.tickBoxSide;
			let energyY = _g.tickBoxEnergyY;

			const padding = 3;//so tick doesn't touch edges of box

			//numbering tick from top left, down to 'v' part and up to top right
			const t1X = left - side/2 + padding;
			const t1Y = side / 6;

			const t2X = left - side / 6;
			const t2Y = side / 2 - padding;

			const t3X = left + side / 2 - padding;
			const t3Y = side / 2 * -1 + padding;

			//create the energy tick
			_g.energyTick = context.add.graphics();
			_g.energyTick.lineStyle(2, 0x123456);
			_g.energyTick.beginPath();

			_g.energyTick.moveTo(t1X, energyY + t1Y);
			_g.energyTick.lineTo(t2X, energyY + t2Y);
			_g.energyTick.lineTo(t3X, energyY + t3Y);
			_g.energyTick.strokePath();

		} else if (action === 'uncheck') {

			_g.energyTick.clear();

		}
	}
	else if (type === 'precision'){
		if (action === 'check') {

			let left = _g.tickBoxLeft;
			let side = _g.tickBoxSide;
			let energyY = _g.tickBoxEnergyY + 30;

			const padding = 3;//so tick doesn't touch edges of box

			//numbering tick from top left, down to 'v' part and up to top right
			const t1X = left - side/2 + padding;
			const t1Y = side / 6;

			const t2X = left - side / 6;
			const t2Y = side / 2 - padding;

			const t3X = left + side / 2 - padding;
			const t3Y = side / 2 * -1 + padding;

			//create the energy tick
			_g.preTick = context.add.graphics();
			_g.preTick.lineStyle(2, 0x123456);
			_g.preTick.beginPath();

			_g.preTick.moveTo(t1X, energyY + t1Y);
			_g.preTick.lineTo(t2X, energyY + t2Y);
			_g.preTick.lineTo(t3X, energyY + t3Y);
			_g.preTick.strokePath();

		} else if (action === 'uncheck') {

			_g.preTick.clear();

		}
	} else if (type === 'touch'){
		if (action === 'check') {

			let left = _g.tickBoxLeft;
			let side = _g.tickBoxSide;
			let energyY = _g.tickBoxEnergyY + 60;

			const padding = 3;//so tick doesn't touch edges of box

			//numbering tick from top left, down to 'v' part and up to top right
			const t1X = left - side/2 + padding;
			const t1Y = side / 6;

			const t2X = left - side / 6;
			const t2Y = side / 2 - padding;

			const t3X = left + side / 2 - padding;
			const t3Y = side / 2 * -1 + padding;

			//create the touch tick
			_g.touchTick = context.add.graphics();
			_g.touchTick.lineStyle(2, 0x123456);
			_g.touchTick.beginPath();

			_g.touchTick.moveTo(t1X, energyY + t1Y);
			_g.touchTick.lineTo(t2X, energyY + t2Y);
			_g.touchTick.lineTo(t3X, energyY + t3Y);
			_g.touchTick.strokePath();

			touchOption("enable")
      //set cookie
     	document.cookie = "Touchscreen-c=1;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax"


		} else if (action === 'uncheck') {

			_g.touchTick.clear();

			touchOption("disable")
      //set cookie
     	document.cookie = "Touchscreen-c=0;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax"


		}
	}
}


function workOutTouchTickBoxValue() {
  res = getCookie("Touchscreen-c");
  if(res === "1") {
  	return true;
  }
  else if(res === "0"){
    //do nothing
  }
  else { //check if touchscreen
  	if(( 'ontouchstart' in window ) || ( navigator.maxTouchPoints > 0 ) || ( navigator.msMaxTouchPoints > 0 )){
      	//expiry date will only work to 2038 on some browsers...
    	document.cookie = "Touchscreen-c=1;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax";
      	return true;
    }
    else {
    	document.cookie = "Touchscreen-c=0;expires=Tue, 19 Jan 2038 03:14:08 GMT;SameSite=Lax";
    }
  }
  return false;
}

function getCookie(cname) { //w3schools.com
  var name = cname+"=";
  var ca = document.cookie.split(';');
  for(var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}


function createVoltageSliderBase(context) {

	const centrex = 400;
	const centrey = 30;

	_g.voltageSlideBaseCentreY = centrey;

	const width = 300;
	const height = 50;

	const blx = centrex - (width/2);
	const bly = centrey + (height/2);
	const brx = centrex + (width/2);
	const trY = centrey - (height/2);//try is a reserved word

	const padl = 10;
	const padr = padl;
	const padb = 5;

	const divisions = 13;
	const spacing = (width - padl - padr)/(divisions -1);

	const background = context.add.rectangle(centrex , centrey , width, height, 0xD9F8FF);

	const bottomLine = context.add.graphics();
	bottomLine.lineStyle(1, 0x55D4FF);
	bottomLine.beginPath();
	bottomLine.moveTo(blx, bly);
	bottomLine.lineTo(brx, bly);
	bottomLine.strokePath();

	const sideLine = context.add.graphics();
	sideLine.lineStyle(1, 0x55D4FF);
	sideLine.beginPath();
	sideLine.moveTo(brx, bly);
	sideLine.lineTo(brx, trY);
	sideLine.strokePath();

	let currdivx = blx + padl;
	const divby = bly - padb;
	const divHeight = 7;
	const divty = divby - divHeight;

	const fontHeightNudge = 12;
	const singDigitLeftNudge = 4;
	const doubleDigitLeftNudge = 8;
	let leftNudge;
	const valy = divty - padb - fontHeightNudge;

	const div = context.add.graphics();
	div.lineStyle(1, 0x000000);
	div.beginPath();

	for (let i = 1; i <= divisions; i++) {

		//set the left bound for the slider
		if (i === 1) {
			_g.voltageSliderLeftBound = currdivx;
		}

		//set a value for placing the slide in the right place on the scale
		if (i === (divisions + 1)/2) {//find the middle value (i.e. 6 V with 0 V start and 12 V end)
			_g.voltageSliderStartX = currdivx;
		}

		//set the right bound for the slider
		if (i === divisions) {
			_g.voltageSliderRightBound = currdivx;
		}

		div.moveTo(currdivx, divby);
		div.lineTo(currdivx, divty);
		div.strokePath();

		if (i-1 < 10) {
			leftNudge = singDigitLeftNudge;
		} else {
			leftNudge = doubleDigitLeftNudge;
		}

		let value = context.add.text(currdivx - leftNudge, valy, i-1, { fontFamily: 'Arial', fontSize: '14px', fill: '#1C849D' });

		currdivx += spacing;
	}

	const nudgeTitleDown = 4;
	const nudgeTitleRight = 90;

	const title = context.add.text(blx + nudgeTitleRight, trY + nudgeTitleDown, 'Battery voltage (V)', { fontFamily: 'Arial', fontSize: '14px', fill: '#BF292A' });

}

function createVoltageSlider(context) {

	const nudgeDown = 10;

	const centrex = 0;
	const centrey = 0;

	const width = 20;
	const height = 40;

	const blx = centrex - (width/2);
	const bly = centrey + (height/2);
	const brx = centrex + (width/2);
	const trY = centrey - (height/2);//try is a reserved word


	const sliderBackground = context.add.rectangle(0, 0, width, height, 0x000000, 0.1);

	const bottomLine = context.add.graphics();
	bottomLine.lineStyle(1, 0x55D4FF);
	bottomLine.beginPath();
	bottomLine.moveTo(blx, bly);
	bottomLine.lineTo(brx, bly);
	bottomLine.strokePath();

	const rightLine = context.add.graphics();
	rightLine.lineStyle(1, 0x55D4FF);
	rightLine.beginPath();
	rightLine.moveTo(brx, bly);
	rightLine.lineTo(brx, trY);
	rightLine.strokePath();

	const topLine = context.add.graphics();
	topLine.lineStyle(1, 0xffffff);
	topLine.beginPath();
	topLine.moveTo(blx, trY);
	topLine.lineTo(brx, trY);
	topLine.strokePath();

	const leftLine = context.add.graphics();
	leftLine.lineStyle(1, 0xffffff);
	leftLine.beginPath();
	leftLine.moveTo(blx, bly);
	leftLine.lineTo(blx, trY);
	leftLine.strokePath();

	const markerLine = context.add.graphics();
	markerLine.lineStyle(1, 0xBF292A);
	markerLine.beginPath();
	markerLine.moveTo(centrex, bly);
	markerLine.lineTo(centrex, trY);
	markerLine.strokePath();

	_g.voltageSlider = context.add.container(_g.voltageSliderStartX, _g.voltageSlideBaseCentreY + nudgeDown, [sliderBackground, bottomLine, rightLine, topLine, leftLine, markerLine ]);

	//setSize sets hit area for interactive
	_g.voltageSlider.setSize(width, height).setInteractive( { cursor: 'pointer' } );

}

function createResistanceSliderBases(context) {

	const centre1x = _g.mpx;
	const centre2x = _g.mpxo - 25; // 25 for gap
	const centre3x = _g.centero + 25;

	const centre1y = 150;
	const centre2y = 520;
	const centre3y = 520;

	_g.resistanceSlideBase1CentreY = centre1y;
	_g.resistanceSlideBase2CentreY = centre2y;

	const aspectRatio = 6;//the width is 6 x the height

	const width = 220;
	const height = width / aspectRatio;

	const bl1x = centre1x - (width/2); // 1 x
	const br1x = centre1x + (width/2);
	const bl1y = centre1y + (height/2); // y
	const tr1Y = centre1y - (height/2);

	const bl2x = centre2x - (width/2); // 2 x
	const br2x = centre2x + (width/2);
	const bl2y = centre2y + (height/2); // y
	const tr2Y = centre2y - (height/2);

	const bl3x = centre3x - (width/2); // 3 x
	const br3x = centre3x + (width/2);
	const bl3y = centre3y + (height/2); // y
	const tr3Y = centre3y - (height/2);

	const padl = 10;
	const padr = padl;
	const padb = 3;

	const scaleStart = 3;
	const scaleEnd = 24;
	const divisions = scaleEnd - scaleStart + 1; //resistance range 3 - 24, so 22 values
	const spacing = (width - padl - padr)/(divisions -1);

	const background1 = context.add.rectangle(centre1x , centre1y , width, height, 0xD9F8FF);
	const background2 = context.add.rectangle(centre2x , centre2y , width, height, 0xD9F8FF);
	const background3 = context.add.rectangle(centre3x , centre3y , width, height, 0xD9F8FF);

	const bottomLine1 = context.add.graphics();
	bottomLine1.lineStyle(1, 0x55D4FF);
	bottomLine1.beginPath();
	bottomLine1.moveTo(bl1x, bl1y);
	bottomLine1.lineTo(br1x, bl1y);
	bottomLine1.strokePath();

	const sideLine1 = context.add.graphics();
	sideLine1.lineStyle(1, 0x55D4FF);
	sideLine1.beginPath();
	sideLine1.moveTo(br1x, bl1y);
	sideLine1.lineTo(br1x, tr1Y);
	sideLine1.strokePath();

	const bottomLine2 = context.add.graphics();
	bottomLine2.lineStyle(1, 0x55D4FF);
	bottomLine2.beginPath();
	bottomLine2.moveTo(bl2x, bl2y);
	bottomLine2.lineTo(br2x, bl2y);
	bottomLine2.strokePath();

	const sideLine2 = context.add.graphics();
	sideLine2.lineStyle(1, 0x55D4FF);
	sideLine2.beginPath();
	sideLine2.moveTo(br2x, bl2y);
	sideLine2.lineTo(br2x, tr2Y);
	sideLine2.strokePath();

	const bottomLine3 = context.add.graphics();
	bottomLine3.lineStyle(1, 0x55D4FF);
	bottomLine3.beginPath();
	bottomLine3.moveTo(bl3x, bl3y);
	bottomLine3.lineTo(br3x, bl3y);
	bottomLine3.strokePath();

	const sideLine3 = context.add.graphics();
	sideLine3.lineStyle(1, 0x55D4FF);
	sideLine3.beginPath();
	sideLine3.moveTo(br3x, bl3y);
	sideLine3.lineTo(br3x, tr3Y);
	sideLine3.strokePath();

	let currdiv1x = bl1x + padl;
	let currdiv2x = bl2x + padl;
	let currdiv3x = bl3x + padl;

	const divHeight = 3;

	const divb1y = bl1y - padb;
	const divt1y = divb1y - divHeight;

	const divb2y = bl2y - padb;
	const divt2y = divb2y - divHeight;

	const divb3y = bl3y - padb;
	const divt3y = divb3y - divHeight;

	const fontHeightNudge = 10;
	const singDigitLeftNudge = 3;
	const doubleDigitLeftNudge = 7;

	let leftNudge;

	const val1y = divt1y - padb - fontHeightNudge;
	const val2y = divt2y - padb - fontHeightNudge;
	const val3y = divt3y - padb - fontHeightNudge;

	const startResistance = 6;
	let scaleValue = scaleStart;
	const scaleDisplayInterval = 3;

	const div = context.add.graphics();
	div.lineStyle(1, 0x000000);
	div.beginPath();

	for (let i = 1; i <= divisions; i++) {

		//set the left bound for the slider
		if (i === 1) {
			_g.resistanceSlider1LeftBound = currdiv1x;
			_g.resistanceSlider2LeftBound = currdiv2x;
			_g.resistanceSlider3LeftBound = currdiv3x;
		}

		//set a value for placing the slide in the right place on the scale
		if (scaleValue === startResistance) {//find the middle value (i.e. 6 V with 0 V start and 12 V end)
			_g.resistanceSlider1StartX = currdiv1x;
			_g.resistanceSlider2StartX = currdiv2x;
			_g.resistanceSlider3StartX = currdiv3x;
		}

		//set the right bound for the slider
		if (i === divisions) {
			_g.resistanceSlider1RightBound = currdiv1x;
			_g.resistanceSlider2RightBound = currdiv2x;
			_g.resistanceSlider3RightBound = currdiv3x;
		}

		div.moveTo(currdiv1x, divb1y);
		div.lineTo(currdiv1x, divt1y);
		div.strokePath();

		div.moveTo(currdiv2x, divb2y);
		div.lineTo(currdiv2x, divt2y);
		div.strokePath();

		div.moveTo(currdiv3x, divb3y);
		div.lineTo(currdiv3x, divt3y);
		div.strokePath();

		if (scaleValue < 10) {
			leftNudge = singDigitLeftNudge;
		} else {
			leftNudge = doubleDigitLeftNudge;
		}

		const valueFontSize = '11px';

		if (scaleValue % scaleDisplayInterval === 0 ) {
			let text = { fontFamily: 'Arial', fontSize: valueFontSize, fill: '#1C849D' };
			context.add.text(currdiv1x - leftNudge, val1y, scaleValue, text);
			context.add.text(currdiv2x - leftNudge, val2y, scaleValue, text);
			context.add.text(currdiv3x - leftNudge, val3y, scaleValue, text);
		}

		currdiv1x += spacing;
		currdiv2x += spacing;
		currdiv3x += spacing;

		scaleValue ++;
	}

	const nudgeTitleDown = 2;
	const nudgeTitleRight = 50;

	var text = { fontFamily: 'Arial', fontSize: '12px', fill: '#000000' };
	context.add.text(bl1x + nudgeTitleRight, tr1Y + nudgeTitleDown, 'Bulb resistance (ohms)', text);
	context.add.text(bl2x + nudgeTitleRight, tr2Y + nudgeTitleDown, 'Bulb resistance (ohms)', text);
	context.add.text(bl3x + nudgeTitleRight, tr3Y + nudgeTitleDown, 'Bulb resistance (ohms)', text);

}

function createResistanceSliders(context) {

	const nudgeDown = 10;

	const centrex = 0;
	const centrey = 0;

	const aspectRatio = 2; //twice as high as wide

	const width = 14;
	const height = width * aspectRatio;

	const blx = centrex - (width/2);
	const bly = centrey + (height/2);
	const brx = centrex + (width/2);
	const trY = centrey - (height/2); //try is a reserved word

	const sliderBackground = () => context.add.rectangle(0, 0, width, height, 0x000000, 0.1);

	const bottomLine = () => {
		let draw = context.add.graphics();
		draw.lineStyle(1, 0x55D4FF);
		draw.beginPath();
		draw.moveTo(blx, bly);
		draw.lineTo(brx, bly);
		draw.strokePath();
		return draw;
	}
	const rightLine = () => {
		let draw = context.add.graphics();
		draw.lineStyle(1, 0x55D4FF);
		draw.beginPath();
		draw.moveTo(brx, bly);
		draw.lineTo(brx, trY);
		draw.strokePath();
		return draw;
	}
	const topLine = () => {
		let draw = context.add.graphics();
		draw.lineStyle(1, 0xffffff);
		draw.beginPath();
		draw.moveTo(blx, trY);
		draw.lineTo(brx, trY);
		draw.strokePath();
		return draw;
	}
	const leftLine = () => {
		let draw = context.add.graphics();
		draw.lineStyle(1, 0xffffff);
		draw.beginPath();
		draw.moveTo(blx, bly);
		draw.lineTo(blx, trY);
		draw.strokePath();
		return draw;
	}
	const markerLine = () => {
		let draw = context.add.graphics();
		draw.lineStyle(1, 0xBF292A);
		draw.beginPath();
		draw.moveTo(centrex, bly);
		draw.lineTo(centrex, trY);
		draw.strokePath();
		return draw;
	}

	const options = () => [sliderBackground(), bottomLine(), rightLine(), topLine(), leftLine(), markerLine()]

	_g.resistanceSlider1 = context.add.container(_g.resistanceSlider1StartX, _g.resistanceSlideBase1CentreY + nudgeDown, options());
	_g.resistanceSlider2 = context.add.container(_g.resistanceSlider2StartX, _g.resistanceSlideBase2CentreY + nudgeDown, options());
	_g.resistanceSlider3 = context.add.container(_g.resistanceSlider3StartX, _g.resistanceSlideBase2CentreY + nudgeDown, options());

	//setSize sets hit area for interactive
	_g.resistanceSlider1.setSize(width, height).setInteractive( { cursor: 'pointer' } );
	_g.resistanceSlider2.setSize(width, height).setInteractive( { cursor: 'pointer' } );
	_g.resistanceSlider3.setSize(width, height).setInteractive( { cursor: 'pointer' } );

}

function initVoltmeterGraphics(context) {

	const voltmeterShadow = context.add.circle(3 , 3 , 30, 0x000000, 0.1);
	_g.voltmeterBackground = context.add.circle(0 , 0 , 30, 0x00ff00, 0.5);
	const titleBackground = context.add.rectangle(0, -38, 80, 20, 0e000000, 0.5);
	const title = context.add.text(-32, -46, 'Voltmeter', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.voltmeterOutput = context.add.text(-15, -15, '--.-', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });
	const unitDisplay = context.add.text(-17, 10, 'VOLTS', { fontFamily: 'Arial', fontSize: '10px', fill: '#000000' });

	_g.leftConnection = context.add.circle(-33, 0, 6, 0x000000);
	_g.rightConnection = context.add.circle(33, 0, 6, 0x000000);

	_g.leftLeadHome = { startx: -30, starty: 0, endx: -60, endy: 0 };
	_g.rightLeadHome = { startx: 30, starty: 0, endx: 60, endy: 0 };

	_g.leftProbe = context.add.circle(0, 0, 15, 0xaaaaaa).setInteractive( { cursor: 'pointer' } );
	_g.rightProbe = context.add.circle(0, 0, 15, 0xaaaaaa).setInteractive( { cursor: 'pointer' } );

	_g.rightProbeVoltage = -1;//these are the 'not on a wire' defaults
	_g.leftProbeVoltage = -1;

	_g.leftProbe.locked = false;
	_g.rightProbe.locked = false;

	_g.rightLead = context.add.graphics();
	_g.rightLead.lineStyle(4, 0xff6633);
	_g.rightLead.beginPath();

	_g.leftLead = context.add.graphics();
	_g.leftLead.lineStyle(4, 0xff6633);
	_g.leftLead.beginPath();

	//_g.voltmeterLeftProbe = context.add.circle(-30, 0, 6, 0x000000);

	_g.voltmeter = context.add.container(_g.voltMeterHomeX, _g.voltMeterHomeY, [ voltmeterShadow, _g.voltmeterBackground, _g.leftConnection, _g.rightConnection, titleBackground, title, _g.voltmeterOutput, unitDisplay ]);
	//setSize sets hit area for interactive
	_g.voltmeter.setSize(_g.voltmeterBackground.width, _g.voltmeterBackground.height).setInteractive( { cursor: 'pointer' } );
	_g.voltmeter.setDepth(1);

	leadSnapBack('left', context);
	leadSnapBack('right', context);

}

function leadSnapBack(lead, context) {

	let vm = _g.voltmeter;

	if(lead === 'left') {

		_g.leftLead.clear();
		_g.leftLead.lineStyle(4, 0xff6633);

		_g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
		_g.leftLead.lineTo(vm.x + _g.leftLeadHome.endx, vm.y + _g.leftLeadHome.endy);
		_g.leftLead.strokePath();

		_g.leftProbe.x = vm.x + _g.leftLeadHome.endx;
		_g.leftProbe.y = vm.y + _g.leftLeadHome.endy;
		_g.leftProbe.bounds = _g.leftProbe.getBounds();

	} else if(lead === 'right') {

		_g.rightLead.clear();
		_g.rightLead.lineStyle(4, 0xff6633);

		_g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
		_g.rightLead.lineTo(vm.x + _g.rightLeadHome.endx, vm.y + _g.rightLeadHome.endy);
		_g.rightLead.strokePath();

		_g.rightProbe.x = vm.x + _g.rightLeadHome.endx;
		_g.rightProbe.y = vm.y + _g.rightLeadHome.endy;
		_g.rightProbe.bounds = _g.rightProbe.getBounds();

	}

}

function initAmmeterGraphics(context) {

	const ammeterShadow = context.add.circle(3 , 3 , 30, 0x000000, 0.1);
	const background = context.add.circle(0 , 0 , 30, 0xFF43FF, 0.8);
	const titleBackground = context.add.rectangle(0, -38, 80, 20, 0e000000, 0.5);
	const title = context.add.text(-32, -46, 'Ammeter', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.ammeterOutput = context.add.text(-13, -15, '-.-', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });
	const unitDisplay = context.add.text(-13, 10, 'AMPS', { fontFamily: 'Arial', fontSize: '10px', fill: '#000000' });

	_g.ammeter = context.add.container(_g.ammeterHomeX, _g.ammeterHomeY, [ ammeterShadow, background, titleBackground, title, _g.ammeterOutput, unitDisplay ]);
	//setSize sets hit area for interactive
	_g.ammeter.setSize(background.width, background.height).setInteractive( { cursor: 'pointer' } );
	_g.ammeter.setDepth(2);

}

function initPowerMeterGraphics(context) {

	const powerMeterShadow = context.add.circle(3 , 3 , 40, 0x000000, 0.1);
	const background = context.add.circle(0 , 0 , 40, 0xffffff, 0.2);
	const titleBackground = context.add.rectangle(3, -38, 100, 20, 0x000000, 0.5);
	const title = context.add.text(-40, -46, 'Power meter', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });

	_g.powerMeterOutput = context.add.text(-12, -15, '-.-', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });
	const unitDisplay = context.add.text(-13, 10, 'WATTS', { fontFamily: 'Arial', fontSize: '10px', fill: '#000000' });

	_g.powerMeter = context.add.container(_g.powerMeterHomeX, _g.powerMeterHomeY, [ powerMeterShadow, background, titleBackground, title, _g.powerMeterOutput, unitDisplay ]);
	//setSize sets hit area for interactive
	_g.powerMeter.setSize(background.width, background.height).setInteractive( { cursor: 'pointer' } );
	_g.powerMeter.setDepth(4);

}

function initStopWatch(context) {

	const stopWatchX = _g.stopWatchHomeX;
	const stopWatchY = _g.stopWatchHomeY;

	//_g.stopWatchX = stopWatchX;
	//_g.stopWatchY = stopWatchY;

	_g.stopWatchStartStopXOffset = -12;
	_g.stopWatchStartStopYOffset = 22;

	_g.stopWatchResetXOffset = 18;
	_g.stopWatchResetYOffset = 17;

	const shadow = context.add.circle(3 , 3 , 50, 0x000000, 0.1);
	const rim = context.add.circle(0 , 0 , 50, 0xF8C646, 1);
	const face = context.add.circle(0 , 0 , 40, 0xE5AF2B, 1);
	const titleBackground = context.add.rectangle(0, -38, 82, 20, 0x000000, 0.5);
	const title = context.add.text(-34, -46, 'Stopwatch', { fontFamily: 'Arial', fontSize: '15px', fill: '#ffffff' });
	const numberBackground = context.add.rectangle(0, -8, 58, 30, 0xEBEEEC, 1);

	_g.stopWatchOutput = context.add.text(-16, -23, '0.0', { fontFamily: 'Arial', fontSize: '24px', fill: '#000000' });

	const unitDisplay = context.add.text(-17, -1, 'SECONDS', { fontFamily: 'Arial', fontSize: '7px', fill: '#000000' });
	_g.stopWatch = context.add.container(stopWatchX, stopWatchY, [ shadow, rim, face, titleBackground, title, numberBackground, _g.stopWatchOutput, unitDisplay ]);

	_g.stopWatch.setSize(82, 76).setInteractive( { cursor: 'pointer' } );
	_g.stopWatch.setDepth(10);

	const startStopRim = context.add.circle(0 , 0 , 12, 0xCF2037, 1);
	const startStopSurface = context.add.circle(0 , 0 , 10, 0xF5626C, 1);
	_g.startStopButton = context.add.container(stopWatchX + _g.stopWatchStartStopXOffset, stopWatchY + _g.stopWatchStartStopYOffset, [ startStopRim, startStopSurface ]);
	_g.startStopButton.setSize(30, 30).setInteractive( { cursor: 'pointer' } );
	_g.startStopButton.setDepth(11);

	_g.startStopButton.on('pointerdown', function () {

		if (_g.stopWatchRunning) {
			_g.stopWatchRunning = false;
		} else {
			_g.stopWatchRunning = true;
		}

	});

	const resetBackground = context.add.rectangle(0, 0, 20, 12, 0x4F4F46, 1);
	const resetSurface = context.add.rectangle(0, 0, 18, 10, 0xB2A4A2, 1);
	_g.stopWatchResetButton = context.add.container(stopWatchX + _g.stopWatchResetXOffset, stopWatchY + _g.stopWatchResetYOffset, [ resetBackground, resetSurface ]);
	//_g.stopWatchResetButton = context.add.container(900, 500, [ resetBackground, resetSurface ]);
	_g.stopWatchResetButton.setSize(20, 12).setInteractive( { cursor: 'pointer' } );
	_g.stopWatchResetButton.setDepth(12);

	_g.stopWatchResetButton.on('pointerdown', function () {

		_g.stopWatchRunning = false;
		resetStopWatch();

	});

	_g.stopWatchIncrement = _g.tickDelay/1000;
	_g.stopWatchSingleDigit = _g.stopWatchOutput.x;

}

function updateStopWatch() {

	const doubleDigitNudge = 7;// moves display left when double digit seconds

	if (_g.stopWatchRunning) {
		_g.stopWatchTime += _g.stopWatchIncrement;

		if (_g.stopWatchTime > 60) {
			resetStopWatch();
		} else if (_g.stopWatchTime >= 10) {
			_g.stopWatchOutput.x = _g.stopWatchSingleDigit - doubleDigitNudge;
		} else {
			_g.stopWatchOutput.x = _g.stopWatchSingleDigit;
		}

		let roundedTime = displayToNdp(_g.stopWatchTime,1);

		_g.stopWatchOutput.setText(roundedTime);
	}

}

function resetStopWatch() {
	_g.stopWatchTime = 0;
	_g.stopWatchOutput.x = _g.stopWatchSingleDigit;
	_g.stopWatchOutput.setText('0.0');
}

function update() {

	if(_g.dragging) {

		switch(_g.dragged) {
			case 'voltageSlider':
				handleVoltageSlider();
				break;
		 	case 'resistanceSlider1':
				handleResistanceSlider(1);
				break;
		 	case 'resistanceSlider2':
				handleResistanceSlider(2);
				break;
			case 'resistanceSlider3':
				handleResistanceSlider(3);
				break;
		 	case 'leftProbe':
				handleDragLeftProbe();
				break;
		 	case 'rightProbe':
				handleDragRightProbe();
				break;
		 	case 'voltmeter':
				dragVoltmeter();
				break;
		 	case 'ammeter':
				dragAmmeter();
				break;
		 	case 'powerMeter':
				dragPowerMeter();
				break;
		 	case 'stopWatch':
				dragStopWatch();
				break;
			default:
				alert("DEBUG: invalid _g.dragged value");
		}
	}
}

function handleDragLeftProbe() {

	let vm = _g.voltmeter;

	_g.leftProbe.x = vm.x + _g.leftLeadHome.endx;
	_g.leftProbe.y = vm.y + _g.leftLeadHome.endy;
	_g.leftProbe.bounds = _g.leftProbe.getBounds();

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

	_g.leftLead.clear();
	_g.leftLead.lineStyle(4, 0xff6633);

	_g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
	_g.leftLead.lineTo(_g.draggedObject.x, _g.draggedObject.y);
	_g.leftLead.strokePath();

	_g.leftProbeVoltage = getProbeVoltage();

	updateVoltmeter();
}


function handleDragRightProbe() {

	let vm = _g.voltmeter;

	_g.rightProbe.x = vm.x + _g.rightLeadHome.endx;
	_g.rightProbe.y = vm.y + _g.rightLeadHome.endy;
	_g.rightProbe.bounds = _g.rightProbe.getBounds();

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

	_g.rightLead.clear();
	_g.rightLead.lineStyle(4, 0xff6633);

	_g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
	_g.rightLead.lineTo(_g.draggedObject.x, _g.draggedObject.y);
	_g.rightLead.strokePath();

	_g.rightProbeVoltage = getProbeVoltage();

	updateVoltmeter();
}

//if the voltmeter is dragged while the lead is on a wire, keep it where it is
function updateLeadWhileLocked(probe) {

	let vm = _g.voltmeter;

	if (probe === 'left') {

		_g.leftLead.clear();
		_g.leftLead.lineStyle(4, 0xff6633);

		_g.leftLead.moveTo(vm.x + _g.leftLeadHome.startx, vm.y + _g.leftLeadHome.starty);
		_g.leftLead.lineTo(_g.leftProbe.x, _g.leftProbe.y);
		_g.leftLead.strokePath();

	} else if (probe === 'right') {

		_g.rightLead.clear();
		_g.rightLead.lineStyle(4, 0xff6633);

		_g.rightLead.moveTo(vm.x + _g.rightLeadHome.startx, vm.y + _g.rightLeadHome.starty);
		_g.rightLead.lineTo(_g.rightProbe.x, _g.rightProbe.y);
		_g.rightLead.strokePath();

	}
}

function checkVoltmeterProbes() {

	if (_g.rightProbeVoltage != -1) {
		_g.rightProbe.locked = true;
	} else {
		_g.rightProbe.locked = false;
		leadSnapBack('right');
	}

	if (_g.leftProbeVoltage != -1) {
		_g.leftProbe.locked = true;
	} else {
		_g.leftProbe.locked = false;
		leadSnapBack('left');
	}

	updateVoltmeter();
}


function dragVoltmeter () {
	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	if(_g.leftProbe.locked) {
		updateLeadWhileLocked('left');
	} else {
		leadSnapBack('left');
	}

	if(_g.rightProbe.locked) {
		updateLeadWhileLocked('right');
	} else {
		leadSnapBack('right');
	}

	_g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();
}

function dragAmmeter() {
	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.zone = getAmmeterCurrent();//-1 if ammeter is not on wire

	if (_g.zone != 'not found') {
		_g.ammeterOnWire = true;
	} else {
		_g.ammeterOnWire = false;
	}

	updateAmmeter();

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
}

function dragStopWatch (){

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.startStopButton.x = _g.stopWatch.x + _g.stopWatchStartStopXOffset;
	_g.startStopButton.y = _g.stopWatch.y + _g.stopWatchStartStopYOffset;

	_g.stopWatchResetButton.x = _g.stopWatch.x + _g.stopWatchResetXOffset;
	_g.stopWatchResetButton.y = _g.stopWatch.y + _g.stopWatchResetYOffset;

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();

}

function dragPowerMeter(){

	_g.draggedObject.x = _g.pointerx - _g.xOffset;
	_g.draggedObject.y = _g.pointery - _g.yOffset;

	_g.bulbMeasuringPowerFor = getBulbIDForPower();

	updatePowerMeter();

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
}

function updatePowerMeter() {

	let powerMeterDisplay;

	if (_g.bulbMeasuringPowerFor) {
		if (_g.precision === 2) _g.powerMeterOutput.x = -22;
		else _g.powerMeterOutput.x = -12;
		powerMeterDisplay = displayToNdp(_g["physPower"+_g.bulbMeasuringPowerFor],
			_g.precision);
	}
	else {
		_g.powerMeterOutput.x = -12;
		powerMeterDisplay = '-.-';
	}

	_g.powerMeterOutput.setText(powerMeterDisplay);

}

function getBulbIDForPower() {

	let probex = _g.draggedObject.x;
	let probey = _g.draggedObject.y;

	//for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	//	_g.bulb1Topy = _g.b1ty - _g.blr;
	//  _g.bulb2Topy = _g.biy - _g.blr;
	if (pointIsInBox(probex, probey, _g.blrlx, _g.bulb1Topy, _g.blrrx, _g.b1ty)) {

		return 1;

	} if (pointIsInBox(probex, probey, _g.blrlxo, _g.bulb2Topy, _g.blrrxo, _g.biy+1)) {  //check zone C3

		return 2;

	} if (pointIsInBox(probex, probey, _g.lampspace, _g.bulb2Topy, _g.blrlxo2, _g.biy+1)) {  //check zone C3

		return 3;

	}

	return 0;

}

function getProbeVoltage(source, probe) {

	let found = false;

	let probex;
	let probey;

	if (source === 'resistance slider') {
		if (probe === 'left') {
			probex = _g.leftProbe.x;
			probey = _g.leftProbe.y;
		}

		if (probe === 'right') {
			probex = _g.rightProbe.x;
			probey = _g.rightProbe.y;
		}
	} else {
		probex = _g.draggedObject.x;
		probey = _g.draggedObject.y;
	}

	let zone;

	let distanceRoundBulb = Math.PI * _g.mr;//measure around the middle of the wire
	let bulbPdLength = distanceRoundBulb + _g.ww;//each short vertical is half a wire width - two verticals for a bulb

	//_g.bulb1Topy = _g.b1ty - _g.blr;
	//_g.bulb2Topy = _g.biy - _g.blr;

	//for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	if (pointIsInBox(probex, probey, _g.lox, _g.toy, _g.clx, _g.tiy+1)) { //check zone 1
		found = true;
		zone = 1;
		_g.measuredVoltageProportion = 1;
	} else if (pointIsInBox(probex, probey, _g.lox, _g.tiy, _g.lix, _g.boy)) {	//check zone 2
		found = true;
		zone = 2;
		_g.measuredVoltageProportion = 1;
	} else if (pointIsInBox(probex, probey, _g.lix-1, _g.biy, _g.blrlxo+1, _g.boy)) {	//check zone 3
		found = true;
		zone = 3;
		_g.measuredVoltageProportion = 1;


	} else if (pointIsInBox(probex, probey, _g.blrlxo, _g.biy-1, _g.bsrlxo, _g.boy)) {	//check zone 4
		found = true;
		zone = 4;

		//As you go up from the middle of the wire upwards towards the beginning of the curve, the potential drops
		let startY = _g.boy - _g.ww/2;//start half a wire thickness from the bottom

		if (probey < startY) {//only reduce potential above midline
			_g.measuredVoltageProportion = 1 - ((startY - probey)/bulbPdLength) *
			_g.physBulb2Resistance/_g.totalBulbResistance;
		} else {
			_g.measuredVoltageProportion = 1;
		}

	} else if (pointIsInBox(probex, probey, _g.blrlxo, _g.bulb2Topy, _g.blrrxo, _g.biy)) {	//check zone 5 - bottom bulb

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.mpxo;
		let height = _g.biy - probey;

		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
			found = true;
			zone = 5;

			//get the angle of the pointer with the centre of the curve - use cos to get the full angle range from Pi to -Pi
			//subtract this from Pi so the distance from the start begins at 0, not Pi
			let pointerAngleRadians = Math.acos(base/distanceFromCentre);

			let distanceFromCurveStart = (Math.PI - pointerAngleRadians) * _g.mr;
			_g.measuredVoltageProportion = 1 - ((_g.ww/2 + distanceFromCurveStart)/bulbPdLength) *
			_g.physBulb2Resistance/_g.totalBulbResistance;
		}

	} else if (pointIsInBox(probex, probey, _g.blrrxo-_g.ww, _g.biy-1, _g.blrrxo, _g.boy)) {	//check zone 6
		found = true;
		zone = 6;

		//As you go up from the top of the wire downwards towards the middle, the potential drops
		let startY = _g.boy;

		if (probey < _g.boy - _g.ww/2) {//only reduce potential above midline
			_g.measuredVoltageProportion = 1 - ((_g.ww/2 + (probey - startY))/bulbPdLength);
		} else {
			_g.measuredVoltageProportion = 1;
		}
		_g.measuredVoltageProportion *= _g.physBulb3Resistance/_g.totalBulbResistance

	}








	if (pointIsInBox(probex, probey, _g.blrrxo-1, _g.biy-1, _g.bsrlxo2-_g.ww+1, _g.boy)) {	//check zone C4
			_g.measuredVoltageProportion = _g.physBulb3Resistance/_g.totalBulbResistance;
			found = true;
			//alert(1)
	}	else if (pointIsInBox(probex, probey, _g.bsrlxo2-_g.ww, _g.biy-1, _g.bsrlxo2, _g.boy)) {	//check zone 6
			found = true;

			//As you go up from the middle of the wire upwards towards the beginning of the curve, the potential drops
			let startY = _g.boy - _g.ww/2;//start half a wire thickness from the bottom

			if (probey < startY) {//only reduce potential above midline
				_g.measuredVoltageProportion = 1 - ((startY - probey)/bulbPdLength);
			} else {
				_g.measuredVoltageProportion = 1;
			}
			_g.measuredVoltageProportion *= _g.physBulb3Resistance/_g.totalBulbResistance;

	} if (pointIsInBox(probex, probey, _g.lampspace, _g.bulb2Topy, _g.blrlxo2, _g.biy+1)) {  //check zone C3

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.centero;
		let height = _g.biy - probey;

		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
			found = true;
			zone = 5;

			//get the angle of the pointer with the centre of the curve - use cos to get the full angle range from Pi to -Pi
			//subtract this from Pi so the distance from the start begins at 0, not Pi
			let pointerAngleRadians = Math.acos(base/distanceFromCentre);

			let distanceFromCurveStart = (Math.PI - pointerAngleRadians) * _g.mr;
			_g.measuredVoltageProportion = (1 - ((_g.ww/2 + distanceFromCurveStart)/bulbPdLength)) *
			_g.physBulb3Resistance/_g.totalBulbResistance;
		}

	} else if (pointIsInBox(probex, probey, _g.blrlxo2-_g.ww, _g.biy-1, _g.blrlxo2, _g.boy)) {	//check zone 6
		found = true;
		zone = 6;

		//As you go up from the top of the wire downwards towards the middle, the potential drops
		let startY = _g.boy;

		if (probey < _g.boy - _g.ww/2) {//only reduce potential above midline
			_g.measuredVoltageProportion = - ((_g.ww/2 + (probey - startY))/bulbPdLength);
		} else {
			_g.measuredVoltageProportion = 0;
		}
		_g.measuredVoltageProportion *= _g.physBulb3Resistance/_g.totalBulbResistance;

	}









	else if (pointIsInBox(probex, probey, _g.blrlxo2 - _g.ww, _g.biy, _g.rox, _g.boy)) {	//check zone 7
		found = true;
		zone = 7;
		_g.measuredVoltageProportion = 0;
	} else if (pointIsInBox(probex, probey, _g.rix-1, _g.toy, _g.rox, _g.biy)) {	//check zone 8
		found = true;
		zone = 8;
		_g.measuredVoltageProportion = 0;
	} else if (pointIsInBox(probex, probey, _g.crx, _g.toy, _g.rix, _g.tiy)) {	//check zone 9
		found = true;
		zone = 9;
		_g.measuredVoltageProportion = 0;
	} else if (pointIsInBox(probex, probey, _g.lix-1, _g.b1ty, _g.blrlx+1, _g.b1by)) {	//check zone 10
		found = true;
		zone = 10;
		_g.measuredVoltageProportion = 1;
	} else if (pointIsInBox(probex, probey, _g.blrlx, _g.b1ty-1, _g.bsrlx, _g.b1by)) {	//check zone 11
		found = true;
		zone = 11;

		//As you go up from the middle of the wire upwards towards the beginning of the curve, the potential drops
		let startY = _g.b1by - _g.ww/2;//start half a wire thickness from the bottom

		if (probey < startY) {//only reduce potential above midline
			_g.measuredVoltageProportion = 1 - ((startY - probey)/bulbPdLength);
		} else {
			_g.measuredVoltageProportion = 1;
		}

	} else if (pointIsInBox(probex, probey, _g.blrlx, _g.bulb1Topy, _g.blrrx, _g.b1ty)) {	//check zone 12 - middle bulb

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.mpx;
		let height = _g.b1ty - probey;

		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
			found = true;
			zone = 12;

			//get the angle of the pointer with the centre of the curve - use cos to get the full angle range from Pi to -Pi
			//subtract this from Pi so the distance from the start begins at 0, not Pi
			let pointerAngleRadians = Math.acos(base/distanceFromCentre);

			let distanceFromCurveStart = (Math.PI - pointerAngleRadians) * _g.mr;
			_g.measuredVoltageProportion = 1 - ((_g.ww/2 + distanceFromCurveStart)/bulbPdLength);
		}

	} else if (pointIsInBox(probex, probey, _g.bsrrx, _g.b1ty-1, _g.blrrx, _g.b1by)) {	//check zone 13
		found = true;
		zone = 13;

		//As you go up from the top of the wire downwards towards the middle, the potential drops
		let startY = _g.b1ty;

		if (probey < _g.b1by - _g.ww/2) {//only reduce potential above midline
			_g.measuredVoltageProportion = 1 - ((_g.ww/2 + distanceRoundBulb + (probey - startY))/bulbPdLength);
		} else {
			_g.measuredVoltageProportion = 0;
		}



		///////////////////////////////////////////////////////////////////////////

		//.......................................................................//

		///////////////////////////////////////////////////////////////////////////


		//_g.blrlxo2 - _g.ww, _g.biy, _g.rox, _g.boy

	} else if (pointIsInBox(probex, probey, _g.blrrx-1, _g.b1ty+1, _g.rix+1, _g.b1by)) {	//check zone 14
		found = true;
		zone = 14;
		_g.measuredVoltageProportion = 0;
	}




	if(found) {
		return _g.measuredVoltageProportion;
		updateVoltmeter();
	} else {
		return -1;
	}
}

function updateVoltmeter() {

	let pdProportion; // independent of battery voltage

	if(_g.leftProbeVoltage === -1 || _g.rightProbeVoltage === -1) {
		_g.voltmeterOutput.x = -15;
		_g.voltmeterDisplay = '--.-';
		_g.voltmeterOutput.setText(_g.voltmeterDisplay);
	} else {
		pdProportion = Math.abs(_g.leftProbeVoltage - _g.rightProbeVoltage);

		// need to do this first
		_g.voltmeterDisplay = displayToNdp(_g.physCellVoltage * pdProportion,
			_g.precision);
		_g.voltmeterOutput.setText(_g.voltmeterDisplay);

		// sort out alignment of text based on value
		if (_g.precision === 2) {
			if(_g.voltmeterDisplay.length === 4) _g.voltmeterOutput.x = -23;
			else _g.voltmeterOutput.x = -31;
		}
		else {
			if(_g.voltmeterDisplay.length === 3) _g.voltmeterOutput.x = -17;
			else _g.voltmeterOutput.x = -23;
		}
	}
}

function updateAmmeter() {

	let currentToDisplay;

	if (_g.ammeterOnWire) {

		if (_g.zone === 'A') {
			currentToDisplay = _g.ammPhysCurrA;
		} else if (_g.zone === 'B') {
			currentToDisplay = _g.ammPhysCurrB;
		} else if (_g.zone === 'C') {
			currentToDisplay = _g.ammPhysCurrC;
		}

		if (_g.precision === 2) _g.ammeterOutput.x = -23;
		else _g.ammeterOutput.x = -13;
		_g.ammeterDisplay = displayToNdp(currentToDisplay, _g.precision);
	} else {
		_g.ammeterOutput.x = -13;
		_g.ammeterDisplay = '-.-';
	}

	_g.ammeterOutput.setText(_g.ammeterDisplay);
}

function getAmmeterCurrent() {

	let found = false;

	let	probex = _g.draggedObject.x;
	let	probey = _g.draggedObject.y;

	let zone;//will have value A, B, C, not numerical

	let distanceRoundBulb = Math.PI * _g.mr;//measure around the middle of the wire
	let bulbPdLength = distanceRoundBulb + _g.ww;//each short vertical is half a wire width - two verticals for a bulb

	//_g.bulb1Topy = _g.b1ty - _g.blr;
	//_g.bulb2Topy = _g.biy - _g.blr;

	//for numbering of zones and abbreviations see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	if (pointIsInBox(probex, probey, _g.lox, _g.toy, _g.clx, _g.tiy+1)) { //check zone A1
		found = true;
		zone = 'A1';
	} else if (pointIsInBox(probex, probey, _g.lox, _g.tiy, _g.lix, _g.mpy)) {	//check zone A2
		found = true;
		zone = 'A2';
	} else if (pointIsInBox(probex, probey, _g.rix-1, _g.toy, _g.rox, _g.mpy+1)) {	//check zone A3
		found = true;
		zone = 'A3';
	} else if (pointIsInBox(probex, probey, _g.crx, _g.toy, _g.rix, _g.tiy)) {	//check zone A4
		found = true;
		zone = 'A4';

	} else if (pointIsInBox(probex, probey, _g.lix-1, _g.b1ty-1, _g.bsrlx, _g.b1by)) {	//check zone B1
		found = true;
		zone = 'B1';


		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////





	} else if (pointIsInBox(probex, probey, _g.blrlx, _g.bulb1Topy, _g.blrrx, _g.b1ty)) {  //check zone B2

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.mpx;
		let height = _g.b1ty - probey;

		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
			found = true;
			zone = 'B2';
		}

	} else if (pointIsInBox(probex, probey, _g.bsrrx, _g.b1ty-1, _g.rix+1, _g.b1by)) {	//check zone B3
		found = true;
		zone = 'B3';

	} else if (pointIsInBox(probex, probey, _g.lox, _g.mpy, _g.lix, _g.boy)) {	//check zone C1
		found = true;
		zone = 'C1';
	} else if (pointIsInBox(probex, probey, _g.lox-1, _g.biy-1, _g.bsrlxo+1, _g.boy)) {	//check zone C2
		found = true;
		zone = 'C2';


		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////





	} else if (pointIsInBox(probex, probey, _g.blrlxo, _g.bulb2Topy, _g.blrrxo, _g.biy+1)) {  //check zone C3

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.mpxo;
		let height = _g.biy - probey;

		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
			found = true;
			zone = 'C3';
		}
		// change when I get the boxes optimized
} else if (pointIsInBox(probex, probey, _g.blrrxo-_g.bsr+1, _g.biy-1, _g.bsrlxo2, _g.boy)) {	//check zone C4
		found = true;
		zone = 'C4';
		var diff = _g.lampspace-_g.blrrxo-1;
} if (pointIsInBox(probex, probey, _g.lampspace, _g.bulb2Topy+1, _g.blrlxo2, _g.biy-1)) {  //check zone C3

		//you know it's in the bulb rectangle boundary, but is it between the inner and the outer radius?
		let base = probex - _g.centero;
		let height = _g.biy - probey;
		//alert(1)
		let distanceFromCentre = Math.sqrt( Math.pow(base, 2) + Math.pow(height, 2) );

		if (distanceFromCentre > _g.bsr && distanceFromCentre < _g.blr) {
			found = true;
			zone = 'C5';
		}

	} else if (pointIsInBox(probex, probey, _g.blrlxo2 - _g.ww, _g.biy, _g.rox, _g.boy)) {	//check zone C5
		found = true;
		zone = 'C7';
	} else if (pointIsInBox(probex, probey, _g.rix, _g.mpy, _g.rox, _g.biy)) {	//check zone C5
		found = true;
		zone = 'C8';
	}

	let zoneToReturn;

	if(!found) {
		zoneToReturn = 'not found';
	} else {
		zoneToReturn = zone.charAt(0);
	}

	return zoneToReturn;
}

function touchOption(action) {
	if(action === "enable") {
      //expand touch areas
      _g.ammeter.input.hitArea.setSize(60,60);
      _g.ammeter.input.hitArea.centerX = 15;
      _g.ammeter.input.hitArea.centerY = 15;
      //
      _g.voltmeter.input.hitArea.setSize(60,60);
      _g.voltmeter.input.hitArea.centerX = 15;
      _g.voltmeter.input.hitArea.centerY = 15;
      //
      _g.leftProbe.input.hitArea.setSize(30,30);
      _g.leftProbe.input.hitArea.x = -10
      _g.leftProbe.input.hitArea.y = -10
      //
      _g.rightProbe.input.hitArea.setSize(30,30);
      _g.rightProbe.input.hitArea.x = -10
      _g.rightProbe.input.hitArea.y = -10
      //
      _g.powerMeter.input.hitArea.setSize(80,80);
      _g.powerMeter.input.hitArea.centerX = 20;
      _g.powerMeter.input.hitArea.centerY = 20;
      //
      _g.stopWatch.input.hitArea.setSize(100,100)
      _g.stopWatch.input.hitArea.x = 0
      _g.stopWatch.input.hitArea.y = 0
      _g.stopWatch.input.hitArea.centerX = 41; //50-(100-82)/2
      _g.stopWatch.input.hitArea.centerY = 38; //50-(100-76)/2

    }
  	else if(action === "disable") {
      //diminish touch areas
      _g.ammeter.input.hitArea.setSize(30,30);
      _g.ammeter.input.hitArea.centerX = 15;
      _g.ammeter.input.hitArea.centerY = 15;
      //
      _g.voltmeter.input.hitArea.setSize(30,30);
      _g.voltmeter.input.hitArea.centerX = 15;
      _g.voltmeter.input.hitArea.centerY = 15;
      //
      _g.leftProbe.input.hitArea.setSize(15,15);
      _g.leftProbe.input.hitArea.x = 0
      _g.leftProbe.input.hitArea.y = 0
      //
      _g.rightProbe.input.hitArea.setSize(15,15);
      _g.rightProbe.input.hitArea.x = 0
      _g.rightProbe.input.hitArea.y = 0
      //
      _g.powerMeter.input.hitArea.setSize(40,40);
      _g.powerMeter.input.hitArea.centerX = 20;
      _g.powerMeter.input.hitArea.centerY = 20;
      //
      _g.stopWatch.input.hitArea.setSize(82,76)
      //order is important
      _g.stopWatch.input.hitArea.centerX = 50;
      _g.stopWatch.input.hitArea.centerY = 50;
      _g.stopWatch.input.hitArea.x = 0
      _g.stopWatch.input.hitArea.y = 0
  }
}

//check if a point (xin, yin) is in a box bounded by top left and bottom right coords
function pointIsInBox(xin, yin, tlx, tly, brx, bry){
	if (xin > tlx && xin < brx && yin > tly && yin < bry) {
		return true;
	} else {
		return false;
	}
}

function displayToNdp(number, n=1) {
	pre = 10**n;
	offset = Math.floor(Math.log10(number || 1));
	if (offset < 0) {
		offset = 0
	}
	//console.log(number, n, offset, pre)
	return (Math.round(number*pre)/pre
		).toPrecision(n+offset+1).toString().slice(0,n+offset+2);
}

function initDraggableItems(context) {

	_g.draggableItems[1] = _g.voltageSlider;
	_g.draggableItems[1].dragId = 'voltageSlider';

	_g.draggableItems[2] = _g.resistanceSlider1;
	_g.draggableItems[2].dragId = 'resistanceSlider1';

	_g.draggableItems[3] = _g.resistanceSlider2;
	_g.draggableItems[3].dragId = 'resistanceSlider2';

	_g.draggableItems[10] = _g.resistanceSlider3; // added resistanceSlider3
	_g.draggableItems[10].dragId = 'resistanceSlider3';

	_g.draggableItems[4] = _g.voltmeter;
	_g.draggableItems[4].dragId = 'voltmeter';

	_g.draggableItems[5] = _g.leftProbe;
	_g.draggableItems[5].dragId = 'leftProbe';

	_g.draggableItems[6] = _g.rightProbe;
	_g.draggableItems[6].dragId = 'rightProbe';

	_g.draggableItems[7] = _g.ammeter;
	_g.draggableItems[7].dragId = 'ammeter';

	_g.draggableItems[8] = _g.powerMeter;
	_g.draggableItems[8].dragId = 'powerMeter';

	_g.draggableItems[9] = _g.stopWatch;
	_g.draggableItems[9].dragId = 'stopWatch';

    _g.draggableItems.forEach(function (item, index) {

        context.input.setDraggable(_g.draggableItems[index]);

    });

    //  The pointer has to move 2 pixels before it's considered as a drag
    context.input.dragDistanceThreshold = 2;

    context.input.on('dragstart', function (pointer, gameObject) {

        _g.draggedObject = gameObject;
        _g.dragged = gameObject.dragId;

        _g.draggableItems.forEach(function (item, index) {

            if(_g.draggedObject === _g.draggableItems[index]) {
                _g.draggedIndex = index;
            }

        });

				if (_g.touch) {
						_g.xOffset = pointer.x - _g.draggedObject.x;
						_g.yOffset = pointer.y - _g.draggedObject.y;
				}
				else {
					_g.xOffset = 0;
					_g.yOffset = 0;
				}

    });

    context.input.on('drag', function (pointer, gameObject, dragX, dragY) {

        _g.pointerx = pointer.x;
        _g.pointery = pointer.y;

        _g.dragging = true;

    });

    context.input.on('dragend', function (pointer, gameObject) {

        checkVoltmeterProbes();
        _g.dragging = false;

        handleSnapBack(context);
    });

}

function handleSnapBack(context) {

	if (_g.dragged === 'voltmeter') {

		if (!_g.leftProbe.locked && !_g.rightProbe.locked  && _g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.voltMeterHomeX;
			_g.draggedObject.y = _g.voltMeterHomeY;

			leadSnapBack('left', context);
			leadSnapBack('right', context);

			_g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();
		}

	} else if (_g.dragged === 'ammeter') {

		if (_g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.ammeterHomeX;
			_g.draggedObject.y = _g.ammeterHomeY;

			_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
		}

	} else if (_g.dragged === 'powerMeter') {

		if (_g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.powerMeterHomeX;
			_g.draggedObject.y = _g.powerMeterHomeY;

			_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
		}

	} else if (_g.dragged === 'stopWatch') {

		if (_g.draggedObject.x > _g.homeAreaX) {
			//snap back
			_g.draggedObject.x = _g.stopWatchHomeX;
			_g.draggedObject.y = _g.stopWatchHomeY;

			_g.startStopButton.x = _g.stopWatch.x + _g.stopWatchStartStopXOffset;
			_g.startStopButton.y = _g.stopWatch.y + _g.stopWatchStartStopYOffset;

			_g.stopWatchResetButton.x = _g.stopWatch.x + _g.stopWatchResetXOffset;
			_g.stopWatchResetButton.y = _g.stopWatch.y + _g.stopWatchResetYOffset;

			_g.draggableItems[_g.draggedIndex].bounds = _g.draggedObject.getBounds();
		}

	}

	//_g.draggableItems[_g.draggedIndex].bounds = _g.voltmeterBackground.getBounds();

}

function handleVoltageSlider() {
	const maxVoltage = 12;
	const minVoltage = 0;
	const voltageRange = maxVoltage - minVoltage;

	let dragProportion;
	let voltage;

	const leftBound = _g.voltageSliderLeftBound;
	const rightBound = _g.voltageSliderRightBound;
	const dragRange = rightBound - leftBound;

		_g.draggedObject.x = _g.pointerx - _g.xOffset;

		if (_g.draggedObject.x < leftBound) {
			_g.draggedObject.x = leftBound;
		}

		if (_g.draggedObject.x > rightBound) {
			_g.draggedObject.x = rightBound;
		}

		_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

		dragProportion = (_g.draggedObject.x - leftBound) / dragRange;

		voltage = minVoltage + (dragProportion * voltageRange);
		changeCellVoltage(voltage);

}

function handleResistanceSlider(bulb) {

	const maxResistance = 24;
	const minResistance = 3;
	const resistanceRange = maxResistance - minResistance;

	let dragProportion;
	let resistance;

	let leftBound = _g['resistanceSlider'+bulb+'LeftBound'];
	let rightBound = _g['resistanceSlider'+bulb+'RightBound'];

	const dragRange = rightBound - leftBound;

	_g.draggedObject.x = _g.pointerx - _g.xOffset;

	if (_g.draggedObject.x < leftBound) {
		_g.draggedObject.x = leftBound;
	}

	if (_g.draggedObject.x > rightBound) {
		_g.draggedObject.x = rightBound;
	}

	_g.draggableItems[_g.draggedIndex].bounds = _g.draggableItems[_g.draggedIndex].getBounds();

	dragProportion = (_g.draggedObject.x - leftBound) / dragRange;

	resistance = minResistance + (dragProportion * resistanceRange);
	changeBulbResistance(bulb, resistance);
	mapPotentials();

}

function changeCellVoltage(newVoltage) {
	_g.physCellVoltage = newVoltage;

	updatePhysics();
	updateVoltmeter();
	updateAmmeter();
	updatePowerMeter();
}

function changeBulbResistance(bulb, newResistance) {

	_g['physBulb'+bulb+'Resistance'] = newResistance;

	updatePhysics();

	checkIfVolmeterNeedsUpdating();

	updateAmmeter();
	updatePowerMeter();
}

function checkIfVolmeterNeedsUpdating() {

	if (_g.leftProbe.locked && _g.rightProbe.locked) {
		_g.leftProbeVoltage = getProbeVoltage('resistance slider', 'left');
		_g.rightProbeVoltage = getProbeVoltage('resistance slider', 'right');

		updateVoltmeter();
	}
}

function expandPowerCircles() {

	const baseSpeed = 10//set for 6 watts
	let powerSpeed1 = Math.floor(baseSpeed * _g.inputPowerProportion1);
	let powerSpeed2 = Math.floor(baseSpeed * _g.inputPowerProportion2);
	let powerSpeed3 = Math.floor(baseSpeed * _g.inputPowerProportion3);

	if (powerSpeed1 < 1) {
		powerSpeed1 = 1;
	}

	if (powerSpeed2 < 1) {
		powerSpeed2 = 1;
	}

	if (powerSpeed3 < 1) {
		powerSpeed3 = 1;
	}

	_g.powerCircle1[_g.powerCircle1Current].setVisible(false);
	_g.powerCircle2[_g.powerCircle2Current].setVisible(false);
	_g.powerCircle3[_g.powerCircle3Current].setVisible(false);

	if (_g.showEnergy) {

		if(_g.physCurrentB > 0.05) {//don't expand the circle if the current is too low

			if (_g.powerCircle1Current + powerSpeed1 < _g.mapSize -1) {
				_g.powerCircle1Current += powerSpeed1;

				_g.powerCircle1[_g.powerCircle1Current].setVisible(true);

			} else {
				_g.powerCircle1[_g.powerCircle1Current].setVisible(false);
				_g.powerCircle1Current = 1;
			}
		}

		if(_g.physCurrentC > 0.05) {//don't expand the circle if the current is too low

			if (_g.powerCircle2Current + powerSpeed2 < _g.mapSize -1) {
				_g.powerCircle2Current += powerSpeed2;

				_g.powerCircle2[_g.powerCircle2Current].setVisible(true);

			} else {
				_g.powerCircle2[_g.powerCircle2Current].setVisible(false);
				_g.powerCircle2Current = 1;
			}

			if (_g.powerCircle3Current + powerSpeed3 < _g.mapSize -1) {
				_g.powerCircle3Current += powerSpeed3;

				_g.powerCircle3[_g.powerCircle3Current].setVisible(true);

			} else {
				_g.powerCircle3[_g.powerCircle3Current].setVisible(false);
				_g.powerCircle3Current = 1;
			}
		}
	}

}

function moveCharges() {
	let wiggleX = 0;
	let wiggleY = 0;

	//Move charges by zone A, B, C

	//Zone A - discontinuous part either side of cell
	for (let i = 1; i <= _g.numberOfChargesA; ++i) {

		_g.energyA[i].position += Math.floor(_g.speed * _g.inputCurrentProportionA);

		//If the charge is going to hit the end of the zone, jump it to the beginning
		if (_g.energyA[i].position > _g.loopLengthA) {
			_g.energyA[i].position = _g.energyA[i].position - _g.loopLengthA;
		}

		if (_g.energyA[i].position < 1 ) {
			_g.energyA[i].position = 1;
		}

		if (_g.energyA[i].position > _g.loopLengthA - 1 ) {
			_g.energyA[i].position = _g.loopLengthA - 1;
		}

		let currentPosition = _g.energyA[i].position;

		let mappedX = _g.elementMapA[currentPosition].xMap;
		let mappedY = _g.elementMapA[currentPosition].yMap;

		//is a number between 0 and 1
		let scale = _g.potentialMapA[currentPosition];

		//add in some wiggle

		//if (Phaser.Math.Between(1, 6) === 4) {
			wiggleX = Phaser.Math.Between(-2, 2);
			wiggleY = Phaser.Math.Between(-2, 2);
		//}

		_g.energyA[i].x = mappedX + wiggleX;
		_g.energyA[i].y = mappedY + wiggleY;

		_g.chargeA[i].x = mappedX + wiggleX;
		_g.chargeA[i].y = mappedY + wiggleY;

 		if (_g.showEnergy) {
	    	_g.energyA[i].scaleX = scale * Math.sqrt(_g.inputCellVoltageProportion);
	    	_g.energyA[i].scaleY = scale * Math.sqrt(_g.inputCellVoltageProportion);
   	 	} else {
   	 		_g.energyA[i].scaleX = 0;
   	 		_g.energyA[i].scaleY = 0;
    	}

	}

	//Zone B - middle bulb
	for (let i = 1; i <= _g.numberOfChargesB; ++i) {

		_g.energyB[i].position += Math.floor(_g.speed * _g.inputCurrentProportionB);

		//If the charge is going to hit the end of the zone, jump it to the beginning
		if (_g.energyB[i].position > _g.loopLengthB) {
			_g.energyB[i].position = _g.energyB[i].position - _g.loopLengthB;
		}

		if (_g.energyB[i].position < 1 ) {
			_g.energyB[i].position = 1;
		}

		if (_g.energyB[i].position > _g.loopLengthB - 1 ) {
			_g.energyB[i].position = _g.loopLengthB - 1;
		}

		let currentPosition = _g.energyB[i].position;

		let mappedX = _g.elementMapB[currentPosition].xMap;
		let mappedY = _g.elementMapB[currentPosition].yMap;

		//is a number between 0 and 1
		let scale = _g.potentialMapB[currentPosition];

		//add in some wiggle

		//if (Phaser.Math.Between(1, 6) === 4) {
			wiggleX = Phaser.Math.Between(-2, 2);
			wiggleY = Phaser.Math.Between(-2, 2);
		//}

		_g.energyB[i].x = mappedX + wiggleX;
		_g.energyB[i].y = mappedY + wiggleY;

		_g.chargeB[i].x = mappedX + wiggleX;
		_g.chargeB[i].y = mappedY + wiggleY;

 		if (_g.showEnergy) {
	    	_g.energyB[i].scaleX = scale * Math.sqrt(_g.inputCellVoltageProportion);
	    	_g.energyB[i].scaleY = scale * Math.sqrt(_g.inputCellVoltageProportion);
   	 	} else {
   	 		_g.energyB[i].scaleX = 0;
   	 		_g.energyB[i].scaleY = 0;
    	}
	}


	//Zone C - bottom bulbs
	for (let i = 1; i <= _g.numberOfChargesC; ++i) {

		_g.energyC[i].position += Math.floor(_g.speed * _g.inputCurrentProportionC);

		//If the charge is going to hit the end of the zone, jump it to the beginning
		if (_g.energyC[i].position > _g.loopLengthC) {
			_g.energyC[i].position = _g.energyC[i].position - _g.loopLengthC;
		}

		if (_g.energyC[i].position < 1 ) {
			_g.energyC[i].position = 1;
		}

		if (_g.energyC[i].position > _g.loopLengthC - 1 ) {
			_g.energyC[i].position = _g.loopLengthC - 1;
		}

		let currentPosition = _g.energyC[i].position;

		let mappedX = _g.elementMapC[currentPosition].xMap;
		let mappedY = _g.elementMapC[currentPosition].yMap;

		//is a number between 0 and 1
		let scale = _g.potentialMapC[currentPosition];

		//add in some wiggle

		//if (Phaser.Math.Between(1, 6) === 4) {
			wiggleX = Phaser.Math.Between(-2, 2);
			wiggleY = Phaser.Math.Between(-2, 2);
		//}

		_g.energyC[i].x = mappedX + wiggleX;
		_g.energyC[i].y = mappedY + wiggleY;

		_g.chargeC[i].x = mappedX + wiggleX;
		_g.chargeC[i].y = mappedY + wiggleY;

 		if (_g.showEnergy) {
	    	_g.energyC[i].scaleX = scale * Math.sqrt(_g.inputCellVoltageProportion);
	    	_g.energyC[i].scaleY = scale * Math.sqrt(_g.inputCellVoltageProportion);
   	 	} else {
   	 		_g.energyC[i].scaleX = 0;
   	 		_g.energyC[i].scaleY = 0;
    	}

	}

}

function initPowerCircles(context) {
	_g.powerCircle1 = [];
	_g.powerCircle2 = [];
	_g.powerCircle3 = [];

	_g.powerCircleAlpha = 0;

	_g.powerCircle1Current = 1;
	_g.powerCircle2Current = 1;
	_g.powerCircle3Current = 1;

	//two phases: 1. inner radius grows slowly, outer expands and fades. 2. Outer radius expands slowly, inner expands quickly
	let alphaStart1 = 0.7;
	let alphaDecrement1 = 0.0035;
	let currentAlpha1 = alphaStart1;

	let thicknessStart1 = 3;//original 3
	let thicknessIncrement1 = 0.5;//original 0.5
	let currentThickness1 = thicknessStart1;

	let radiusStart1 = 45;//original 60
	let radiusIncrement1 = 0.3;//original 0.4
	let currentRadius1 = radiusStart1;

	_g.mapSize = 200;//must be even, since it's halved and used as the index of an array

	//for location coordinate references see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

	for (var i = 1; i < _g.mapSize / 2; ++i) {
		currentAlpha1 -= alphaDecrement1;
		currentThickness1 += thicknessIncrement1;
		currentRadius1 += radiusIncrement1;

		_g.powerCircle1[i] = context.add.circle(_g.mpx, _g.b1ty, currentRadius1);
		_g.powerCircle1[i].setStrokeStyle(currentThickness1, 0xff0000, currentAlpha1);
		_g.powerCircle1[i].setVisible(false);

		_g.powerCircle2[i] = context.add.circle(_g.mpxo, _g.biy, currentRadius1);
		_g.powerCircle2[i].setStrokeStyle(currentThickness1, 0xff0000, currentAlpha1);
		_g.powerCircle2[i].setVisible(false);

		_g.powerCircle3[i] = context.add.circle(_g.centero, _g.biy, currentRadius1);
		_g.powerCircle3[i].setStrokeStyle(currentThickness1, 0xff0000, currentAlpha1);
		_g.powerCircle3[i].setVisible(false);

	}

	let alphaStart2 = currentAlpha1;
	let alphaDecrement2 = 0.0034;
	let currentAlpha2 = alphaStart2;

	let thicknessStart2 = currentThickness1;

	let thicknessDecrement2 = 0.15;//original 0.2
	let currentThickness2 = thicknessStart2;

	let radiusStart2 = currentRadius1;
	let radiusIncrement2 = 0.375;//original 0.5
	let currentRadius2 = radiusStart2;

	for (var i = _g.mapSize / 2; i <= _g.mapSize; ++i) {
		currentAlpha2 -= alphaDecrement2;
		currentThickness2 -= thicknessDecrement2;
		currentRadius2 += radiusIncrement2;

		_g.powerCircle1[i] = context.add.circle(_g.mpx, _g.b1ty, currentRadius2);
		_g.powerCircle1[i].setStrokeStyle(currentThickness2, 0xff0000, currentAlpha2);
		_g.powerCircle1[i].setVisible(false);

		_g.powerCircle2[i] = context.add.circle(_g.mpxo, _g.biy, currentRadius2);
		_g.powerCircle2[i].setStrokeStyle(currentThickness2, 0xff0000, currentAlpha2);
		_g.powerCircle2[i].setVisible(false);

		_g.powerCircle3[i] = context.add.circle(_g.centero, _g.biy, currentRadius2);
		_g.powerCircle3[i].setStrokeStyle(currentThickness2, 0xff0000, currentAlpha2);
		_g.powerCircle3[i].setVisible(false);

	}

}

function placeCharges(context) {

	let spacingOnElementMap = Math.floor(_g.totalLoopLength/_g.totalCharges);
	_g.spacingOnElementMap = spacingOnElementMap;
	//calculate number of charges in each zone
	// for labelling conventions see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	const energyRadius = 16;
	const chargeRadius = 3;

	_g.numberOfChargesA = Math.floor(_g.loopLengthA * _g.totalCharges / _g.totalLoopLength);
	_g.numberOfChargesB = Math.floor(_g.loopLengthB * _g.totalCharges / _g.totalLoopLength);
	_g.numberOfChargesC = Math.floor(_g.loopLengthC * _g.totalCharges / _g.totalLoopLength);

	// place charges by zone

	let currentPosition = 1;

	//Zone A
	for (let i = 1; i <= _g.numberOfChargesA; ++i) {

		let mappedX = _g.elementMapA[currentPosition].xMap;
		let mappedY = _g.elementMapA[currentPosition].yMap;

		let scale = _g.potentialMapA[currentPosition];

    	_g.energyA[i] = context.add.circle(mappedX, mappedY, energyRadius, 0xff0000);
    	_g.energyA[i].alpha = 0.5;
    	_g.energyA[i].scaleX = scale;
    	_g.energyA[i].scaleY = scale;

    	_g.energyA[i].position = currentPosition;

    	_g.chargeA[i] = context.add.circle(mappedX, mappedY, chargeRadius, 0x000000);

    	currentPosition += spacingOnElementMap;

	}
	// eeek, but it works
	spacingOnElementMap = Math.floor(_g.totalLoopLength/_g.totalCharges)+10;
	currentPosition = Math.floor(spacingOnElementMap/2);

	//Zone B
	for (let i = 1; i <= _g.numberOfChargesB; ++i) {

		let mappedX = _g.elementMapB[currentPosition].xMap;
		let mappedY = _g.elementMapB[currentPosition].yMap;

		let scale = _g.potentialMapB[currentPosition];

    	_g.energyB[i] = context.add.circle(mappedX, mappedY, energyRadius, 0xff0000);
    	_g.energyB[i].alpha = 0.5;
    	_g.energyB[i].scaleX = scale;
    	_g.energyB[i].scaleY = scale;

    	_g.energyB[i].position = currentPosition;

    	_g.chargeB[i] = context.add.circle(mappedX, mappedY, chargeRadius, 0x000000);

    	currentPosition += spacingOnElementMap;

	}
	// eeek, but it works
	spacingOnElementMap = Math.floor(_g.totalLoopLength/_g.totalCharges)+6;
	currentPosition = Math.floor(spacingOnElementMap/2);

	//Zone C
	for (let i = 1; i <= _g.numberOfChargesC; ++i) {

		let mappedX = _g.elementMapC[currentPosition].xMap;
		let mappedY = _g.elementMapC[currentPosition].yMap;

		let scale = _g.potentialMapC[currentPosition];

    	_g.energyC[i] = context.add.circle(mappedX, mappedY, energyRadius, 0xff0000);
    	_g.energyC[i].alpha = 0.5;
    	_g.energyC[i].scaleX = scale;
    	_g.energyC[i].scaleY = scale;

    	_g.energyC[i].position = currentPosition;

    	_g.chargeC[i] = context.add.circle(mappedX, mappedY, chargeRadius, 0x000000);

    	if (currentPosition + spacingOnElementMap < _g.loopLengthC) {
    		currentPosition += spacingOnElementMap;
    	} else {
    		break;
    	}

	}

}

function mapPotentials() {
	_g.potentialMapA = [];
	_g.potentialMapB = [];
	_g.potentialMapC = [];

	let cumTotalA = 0;
	let cumTotalB = 0;
	let cumTotalC = 0;

	var cellVoltageScale = 1;
	const startcellVoltageScale = cellVoltageScale;

	//Handling one zone of A, B and C at a time
	// for labelling conventions see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

	//Zone A - the discontinuous high current part either side of the battery

	//from the left of the cell to the lefthand junction
	for (let i = cumTotalA; i < ( _g.l1 + _g.l2) * _g.mapMult; ++i){
		_g.potentialMapA[i] = cellVoltageScale;
	}

	cumTotalA += (_g.l1 + _g.l2) * _g.mapMult;

	//from the right junction to the right of the cell
	for (let i = cumTotalA; i < cumTotalA + (( _g.l3 + _g.l4) * _g.mapMult); ++i){
		_g.potentialMapA[i] = 0;
	}

	cumTotalA += (_g.l3 + _g.l4) * _g.mapMult;

	//Zone B - the middle section from the left junction, through the bulb to the right junction

	//from the left junction to the bottom of the small vertical join with the bulb
	for (let i = cumTotalB; i < cumTotalB + (_g.l5 * _g.mapMult); ++i){
		_g.potentialMapB[i] = cellVoltageScale;
	}

	cumTotalB += _g.l5 * _g.mapMult;

	//round the middle bulb including the two little vertical joins
	let distanceRound = 0;
	let proportion;

	let bulbTravel = (_g.l6 + _g.l7 + _g.l8) * _g.mapMult;

	for (let i = cumTotalB; i < cumTotalB + bulbTravel; ++i) {
		proportion = distanceRound/bulbTravel;
		_g.potentialMapB[i] = Math.sqrt(cellVoltageScale - (proportion * cellVoltageScale));

		distanceRound += 1;
	}

	cumTotalB += bulbTravel;//bulb travel already has * g.mapMult in it

	//from the bottom of the little right vertical to the right junction
	for (let i = cumTotalB; i < cumTotalB + (_g.l9 * _g.mapMult); ++i){
		_g.potentialMapB[i] = 0;
	}

	cumTotalB += _g.l9 * _g.mapMult;

	//Zone C - the bottom section, from the left junction, round the bottom bulb and back up to the right junction

	//from the left junction to the bottom of the small vertical join with the bulb
	for (let i = cumTotalC; i < (_g.l10 + _g.l11) * _g.mapMult; ++i){
		_g.potentialMapC[i] = cellVoltageScale;
	}

	cumTotalC += (_g.l10 + _g.l11) * _g.mapMult;





	//round the left bottom bulb including the two little vertical joins
	distanceRound = 0;

	bulbTravel = (_g.l12 + _g.l13 + _g.l14) * _g.mapMult;

	var diff = 1 - _g.physBulb3Resistance/_g.totalBulbResistance;

	for (let i = cumTotalC; i < cumTotalC + bulbTravel; ++i) {
		proportion = distanceRound/bulbTravel;
		_g.potentialMapC[i] = Math.sqrt(cellVoltageScale - (proportion * cellVoltageScale));

		distanceRound += diff;
	}

	cumTotalC += bulbTravel;//bulb travel already has * g.mapMult in it




	var val = _g.potentialMapC[cumTotalC-1];

	//from the bottom of the little right vertical to the right junction
	for (let i = cumTotalC; i < cumTotalC + _g.l15 * _g.mapMult; ++i){
		_g.potentialMapC[i] = val;
	}

	cumTotalC += _g.l15 * _g.mapMult;




	bulbTravel = (_g.extra_l4 + _g.extra_l1 + _g.extra_l3) * _g.mapMult;

	var diff = _g.physBulb3Resistance/_g.totalBulbResistance;

	for (let i = cumTotalC; i < cumTotalC + bulbTravel; ++i) {
		proportion = distanceRound/bulbTravel;
		_g.potentialMapC[i] = Math.sqrt(cellVoltageScale - (proportion * cellVoltageScale));

		distanceRound += diff;
	}

	cumTotalC += bulbTravel;//bulb travel already has * g.mapMult in it

}

function initPhysics() {

	//These are so you have something to compare the speed of the black dots, the size of the energy circles
	//and the rate of the power circle
	_g.physRefCellVoltage = 6;
	_g.physRefCurrent = 1;
	_g.physRefPower = _g.physRefCellVoltage * _g.physRefCurrent;

	//These define the variables and also set them to starting values for the sliders that will control them
	_g.physCellVoltage = 6;
	_g.physBulb1Resistance = 6;
	_g.physBulb2Resistance = 6;
	_g.physBulb3Resistance = 6;

	_g.physCurrentA = 2;
	_g.physCurrentB = 1;
	_g.physCurrentC = 1;

	_g.physPower1;
	_g.physPower2;

	//These are the proportions that are used to control current, energy circles and power circle
	_g.inputCellVoltageProportion = 1;
	_g.inputCurrentProportion = 1;

	updatePhysics();
}

function updatePhysics() {
	_g.physCurrentB = _g.physCellVoltage/_g.physBulb1Resistance;
	_g.totalBulbResistance = (_g.physBulb2Resistance+_g.physBulb3Resistance);
	_g.physCurrentC = _g.physCellVoltage/(_g.totalBulbResistance);

	_g.physCurrentA = _g.physCurrentB + _g.physCurrentC;

	/*
	let totalResistance = _g.physBulb2Resistance + _g.physBulb3Resistance;
  let bulb1pd = _g.physCellVoltage * _g.physBulb2Resistance / totalResistance;
	let bulb2pd = _g.physCellVoltage * _g.physBulb3Resistance / totalResistance;
	*/

	//the ammeter current needs to show the current law without rounding errors, so make sure current law applies
	_g.ammPhysCurrB = _g.physCurrentB;
	_g.ammPhysCurrC = _g.physCurrentC;

	_g.ammPhysCurrA = _g.ammPhysCurrB + _g.ammPhysCurrC;

	_g.physPower1 = _g.physCellVoltage * _g.physCurrentB;
	var currentsquared = _g.physCurrentC * _g.physCurrentC;
	// V = IR; I = V / R; R = V / I; Power = VI = I**2R
	_g.physPower2 = currentsquared  * _g.physBulb2Resistance;
  _g.physPower3 = currentsquared * _g.physBulb3Resistance;

	_g.inputCellVoltageProportion = _g.physCellVoltage / _g.physRefCellVoltage;

	_g.inputCurrentProportionA = _g.physCurrentA / _g.physRefCurrent;
	_g.inputCurrentProportionB = _g.physCurrentB / _g.physRefCurrent;
	_g.inputCurrentProportionC = _g.physCurrentC / _g.physRefCurrent;

	_g.inputPowerProportion1 = _g.physPower1 / _g.physRefPower;
	_g.inputPowerProportion2 = _g.physPower2 / _g.physRefPower;
	_g.inputPowerProportion3 = _g.physPower3 / _g.physRefPower;

	//mapPotentials();
}

function mapElements() {

	//The elements are mapped in three zones A, B, C which may have different currents
	//for naming see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	_g.elementMapA = [];
	_g.elementMapB = [];
	_g.elementMapC = [];

	let cumTotalA = 0;
	let cumTotalB = 0;
	let cumTotalC = 0;

	let diff = 0; // used to add the difference in i value, not the absolute number;

	//Zone A is discontinuous - it starts from the left of the cell anticlockwise to the left junction
	//then starts again at the right junction and goes back to the right of the cell
	//for naming see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

	//left of cell to top left corner
	const l1 = Math.floor(_g.clx - _g.mlx);
	for (let i = 1; i < l1 * _g.mapMult; ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapA[i] = { xMap: _g.clx - diff, yMap: _g.mty };
	}

	cumTotalA += (l1 * _g.mapMult);

	//topleft corner to left junction
	const l2 = Math.floor(_g.mpy - _g.mty);
	diff = 0;
	for (let i = cumTotalA; i < cumTotalA + (l2 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapA[i] = { xMap: _g.mlx, yMap: _g.mty + diff };
	}

	cumTotalA += (l2 * _g.mapMult);

	//right junction to top right corner
	const l3 = Math.floor(_g.mpy - _g.mty);
	diff = 0;
	for (let i = cumTotalA; i < cumTotalA + (l3 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapA[i] = { xMap: _g.mrx, yMap: _g.mpy - diff };
	}

	cumTotalA += (l3 * _g.mapMult);

	//top left corner to right of cell
	const l4 = Math.floor(_g.mrx - _g.crx);
	diff = 0;
	for (let i = cumTotalA; i < cumTotalA + (l4 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapA[i] = { xMap: _g.mrx - diff, yMap: _g.mty };
	}

	cumTotalA += (l4 * _g.mapMult);

	//Zone B is from the left junction through the top bulb to the right junction

	//left junction to short vertical on left of middle bulb
	const l5 = Math.floor(_g.mblx - _g.mlx);
	diff = 0;
	for (let i = 1; i < l5 * _g.mapMult; ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapB[i] = { xMap: _g.mlx + diff, yMap: _g.mpy };
	}

	cumTotalB += (l5 * _g.mapMult);

	//bottom of short vertical on left of middle bulb to the top of the short vertical
	const l6 = Math.floor(_g.mpy - _g.b1ty);
	diff = 0;
	for (let i = cumTotalB; i < cumTotalB + (l6 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapB[i] = { xMap: _g.mblx, yMap: _g.mpy - diff };
	}

	cumTotalB += (l6 * _g.mapMult);

	//round the curve of the middle bulb
	let distanceRound = 0;
	const l7 = Math.floor(Math.PI * _g.mr);

	for (let i = cumTotalB; i < cumTotalB + (l7 * _g.mapMult); ++i) {

		let coords = getCoordsForBulb(distanceRound, l7, _g.mr);

		_g.elementMapB[i] = { xMap: _g.mpx - coords.xVal, yMap: _g.b1ty - coords.yVal };

		distanceRound += (1 / _g.mapMult);
	}

	cumTotalB += (l7 * _g.mapMult);

	//top of short vertical on right of middle bulb to its bottom
	const l8 = Math.floor(_g.mpy - _g.b1ty);
	diff = 0;
	for (let i = cumTotalB; i < cumTotalB + (l8 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapB[i] = { xMap: _g.mbrx, yMap: _g.b1ty + diff };
	}

	cumTotalB += (l8 * _g.mapMult);

	//end of short vertical on right of middle bulb to right junction
	const l9 = Math.floor(_g.mrx - _g.mbrx);
	diff = 0;
	for (let i = cumTotalB; i < cumTotalB + (l9 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapB[i] = { xMap: _g.mbrx + diff, yMap: _g.mpy };
	}

	cumTotalB += (l9 * _g.mapMult);

	//Zone C is from the left junction through the bottom bulb to the right junction

	//left junction to bottom left corner
	const l10 = Math.floor(_g.mby - _g.mpy);
	diff = 0;
	for (let i = 1; i < l10 * _g.mapMult; ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: _g.mlx, yMap: _g.mpy + diff };
	}

	cumTotalC += (l10 * _g.mapMult);

	//bottom left corner to short vertical on left of bottom bulb
	const l11 = Math.floor(_g.mblxo - _g.mlx);
	diff = 0;
	for (let i = cumTotalC; i < cumTotalC + (l11 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: _g.mlx + diff, yMap: _g.mby };
	}

	cumTotalC += (l11 * _g.mapMult);

	//bottom of short vertical on left of middle bulb to the top of the short vertical
	const l12 = Math.floor(_g.mby - _g.biy);
	diff = 0;
	for (let i = cumTotalC; i < cumTotalC + (l12 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: _g.mblxo, yMap: _g.mby - diff };
	}

	cumTotalC += (l12 * _g.mapMult);

	//round the curve of the bottom bulb
	distanceRound = 0;
	const l13 = Math.floor(Math.PI * _g.mr);

	for (let i = cumTotalC; i < cumTotalC + (l13 * _g.mapMult); ++i) {

		let coords = (()=>getCoordsForBulb(distanceRound, l13, _g.mr))();

		_g.elementMapC[i] = { xMap: _g.mpxo - coords.xVal, yMap: _g.biy - coords.yVal };

		distanceRound += (1 / _g.mapMult);
	}

	cumTotalC += (l13 * _g.mapMult);

	//top of short vertical on right of bottom bulb to its bottom
	const l14 = Math.floor(_g.mby - _g.biy);
	diff = 0;
	for (let i = cumTotalC; i < cumTotalC + (l14 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: _g.mbrxo, yMap: _g.biy + diff };
	}

	cumTotalC += (l14 * _g.mapMult);

	//end of short vertical on right of bottom bulb to bottom right corner
	const l15 = Math.floor(_g.lampspace - _g.mbrxo + _g.ww / 2 );
	diff = 0;
	for (let i = cumTotalC; i < cumTotalC + (l15 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: _g.mbrxo + diff, yMap: _g.mby };
	}

	cumTotalC += (l15 * _g.mapMult);

	//up short vertical of bulb #2
 	var calc = _g.lampspace + _g.ww / 2
	//bottom of short vertical on left of middle bulb to the top of the short vertical
	const extra_l4 = Math.floor(_g.mby - _g.biy);
	diff = 0;
	for (let i = cumTotalC; i < cumTotalC + (extra_l4 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: calc, yMap: _g.mby - diff };
	}

	cumTotalC += (extra_l4 * _g.mapMult);

	//round the curve of the bottom bulb #2
	distanceRound = 0;
	const extra_l1 = Math.floor(Math.PI * _g.mr);

	calc = (_g.lampspace + _g.outerpoint) / 2;
	for (let i = cumTotalC; i < cumTotalC + (extra_l1 * _g.mapMult); ++i) {

		let coords = getCoordsForBulb(distanceRound, extra_l1, _g.mr);

		_g.elementMapC[i] = { xMap: calc - coords.xVal, yMap: _g.biy - coords.yVal };

		distanceRound += (1 / _g.mapMult);
	}

	cumTotalC += (extra_l1 * _g.mapMult);

	calc = _g.outerpoint - _g.ww / 2;
	//top of short vertical on right of bottom bulb to its bottom
	const extra_l3 = Math.floor(_g.mby - _g.biy);
	diff = 0;
	for (let i = cumTotalC; i < cumTotalC + (extra_l3 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: calc, yMap: _g.biy + diff };
	}

	cumTotalC += (extra_l3 * _g.mapMult);


	//end of short vertical on right of bottom bulb to bottom right corner
	const extra_l2 = Math.floor(_g.mrx - _g.outerpoint + _g.ww / 2);
	diff = -_g.ww / 2;
	for (let i = cumTotalC; i < cumTotalC + (extra_l2 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: _g.outerpoint + diff, yMap: _g.mby };
	}

	cumTotalC += (extra_l2 * _g.mapMult);

	//bottom right corner to right junction
	const l16 = Math.floor(_g.mby - _g.mpy);
	diff = 0;
	for (let i = cumTotalC; i < cumTotalC + (l16 * _g.mapMult); ++i) {
		diff += (1 / _g.mapMult);
		_g.elementMapC[i] = { xMap: _g.mrx, yMap: _g.mby - diff };
	}

	cumTotalC += (l16 * _g.mapMult);

	_g.loopLengthA = cumTotalA;
	_g.loopLengthB = cumTotalB;
	_g.loopLengthC = cumTotalC;

	_g.totalLoopLength = cumTotalA + cumTotalB + cumTotalC;

	//make available to the map potentials function
	_g.l1 = l1;
	_g.l2 = l2;
	_g.l3 = l3;
	_g.l4 = l4;
	_g.l5 = l5;
	_g.l6 = l6;
	_g.l7 = l7;
	_g.l8 = l8;
	_g.l9 = l9;
	_g.l10 = l10;
	_g.l11 = l11;
	_g.l12 = l12;
	_g.l13 = l13;
	_g.l14 = l14;
	_g.l15 = l15;
	_g.l16 = l16;
	_g.extra_l1 = extra_l1;
	_g.extra_l2 = extra_l2;
	_g.extra_l3 = extra_l3;
	_g.extra_l4 = extra_l4;

}

function getCoordsForBulb(distance, totalDistance, radius) {
	let proportion = distance/totalDistance;

	let angleDegrees = proportion * 180;
	let angleRadians = angleDegrees* Math.PI/180;

	return { xVal: radius * Math.cos(angleRadians), yVal: radius * Math.sin(angleRadians)};
}

function createCircuitOutline(context) {

	//variables are defined in a diagram at https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

	const circuitLines = context.add.graphics({ lineStyle: { width: 1, color: 0x000000 } });

	const bulb2offset = -91; // for another bulb line length 41 -91

	const toy = 80;
	const lox = 200;
	const rox = 600;
	const boy = 440;
	const bsr = 24;
	const ww = 22;
	const cw = 15;

	const celllh = ww * 2.8;
	const cellrh = ww * 1.8;

	const mpx = lox + ((rox - lox)/2); // 400
	const mpxo = mpx + bulb2offset; // mpx offset
	const tiy = toy + ww;
	const lix = lox + ww;
	const rix = rox - ww;
	const biy = boy - ww;

	const hh = (biy - tiy)/2;
	const mpy = tiy + hh;
	const b1ty = mpy - ww/2;
	const b1by = b1ty + ww;

	const blr = bsr + ww;
	const gr = blr + ww;

	const bsrlx = mpx - bsr;
	const bsrrx = mpx + bsr;

	const blrlx = mpx - blr;
	const blrrx = mpx + blr;

	const bsrlxo = mpxo - bsr;
	const bsrrxo = mpxo + bsr;

	const blrlxo = mpxo - blr;
	const blrrxo = mpxo + blr;

	const bsrrxo2 = rix - bsrlxo + lix;
	const bsrlxo2 = bsrrxo2 - bsr * 2;
	const lampspace = bsrlxo2 - ww;
	const centero = bsrrxo2 - bsr;

	const clx = mpx - (cw / 2);
	const crx = clx + cw;

	//draw the outer part of the circuit starting from the cell and moving anticlockwise
	//line IDs are defined in a diagram at https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing
	const l1 = new Phaser.Geom.Line(clx, toy, lox, toy);
	const l2 = new Phaser.Geom.Line(lox, toy, lox, boy);
	const l3 = new Phaser.Geom.Line(lox, boy, bsrlxo, boy);
	const l4 = new Phaser.Geom.Line(bsrlxo, boy, bsrlxo, biy);

	const l5 = context.add.graphics();
	l5.lineStyle(1, 0x000000, 1);
	l5.beginPath();
	l5.arc(mpxo, biy, bsr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	l5.strokePath();

	const l6 = new Phaser.Geom.Line(bsrrxo, biy, bsrrxo, boy);
	// remove line 7
	const extra_l1 = new Phaser.Geom.Line(bsrrxo, boy, bsrlxo2, boy);
	const extra_l2 = new Phaser.Geom.Line(bsrlxo2, boy, bsrlxo2, biy);
	const extra_l3 = new Phaser.Geom.Line(bsrrxo2, biy, bsrrxo2, boy);
	const extra_l4 = new Phaser.Geom.Line(bsrrxo2, boy, rox, boy);
	const extra_l5 = new Phaser.Geom.Line(blrrxo, biy, lampspace, biy);

	const extra_l6 = context.add.graphics();
	extra_l6.lineStyle(1, 0x000000, 1);
	extra_l6.beginPath();
	extra_l6.arc(centero, biy, bsr, // small arc
		Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	extra_l6.strokePath();
	extra_l6.beginPath();
	extra_l6.arc(centero, biy, blr, // big arc
		Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	extra_l6.strokePath();

	const extra_l7 = new Phaser.Geom.Line(bsrrxo2 + ww, biy, rix, biy);
	const l8 = new Phaser.Geom.Line(rox, boy, rox, toy);
	const l9 = new Phaser.Geom.Line(rox, toy, crx, toy);

	circuitLines.strokeLineShape(l1);
	circuitLines.strokeLineShape(l2);
	circuitLines.strokeLineShape(l3);
	circuitLines.strokeLineShape(l4);
	circuitLines.strokeLineShape(l6);
	circuitLines.strokeLineShape(extra_l1);
	circuitLines.strokeLineShape(extra_l2);
	circuitLines.strokeLineShape(extra_l3);
	circuitLines.strokeLineShape(extra_l4);
	circuitLines.strokeLineShape(extra_l5);
	circuitLines.strokeLineShape(extra_l6);
	circuitLines.strokeLineShape(extra_l7);
	circuitLines.strokeLineShape(l8);
	circuitLines.strokeLineShape(l9);
	//round the top loop inner line, starting from the lhs of the cell and going anticlockwise

	const l10 = new Phaser.Geom.Line(clx, tiy, lix, tiy);
	const l11 = new Phaser.Geom.Line(lix, tiy, lix, b1ty);
	const l12 = new Phaser.Geom.Line(lix, b1ty, blrlx, b1ty);
	const l14 = new Phaser.Geom.Line(blrrx, b1ty, rix, b1ty);
	const l15 = new Phaser.Geom.Line(rix, b1ty, rix, tiy);
	const l16 = new Phaser.Geom.Line(rix, tiy, crx, tiy);

	const l13 = context.add.graphics();
	l13.lineStyle(1, 0x000000, 1);
	l13.beginPath();
	l13.arc(mpx, b1ty, blr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	l13.strokePath();

	circuitLines.strokeLineShape(l10);
	circuitLines.strokeLineShape(l11);
	circuitLines.strokeLineShape(l12);
	circuitLines.strokeLineShape(l14);
	circuitLines.strokeLineShape(l15);
	circuitLines.strokeLineShape(l16);

	//round the bottom inner loop starting from the top bulb and working anticlockwise

	const l17 = new Phaser.Geom.Line(bsrlx, b1by, lix, b1by);
	const l18 = new Phaser.Geom.Line(lix, b1by, lix, biy);
	const l19 = new Phaser.Geom.Line(lix, biy, blrlxo, biy);
	// remove line 21
	const l22 = new Phaser.Geom.Line(rix, biy, rix, b1by);
	const l23 = new Phaser.Geom.Line(rix, b1by, bsrrx, b1by);
	const l24 = new Phaser.Geom.Line(bsrrx, b1by, bsrrx, b1ty);
	const l26 = new Phaser.Geom.Line(bsrlx, b1by, bsrlx, b1ty);

	circuitLines.strokeLineShape(l17);
	circuitLines.strokeLineShape(l18);
	circuitLines.strokeLineShape(l19);

	const l20 = context.add.graphics();
	l20.lineStyle(1, 0x000000, 1);
	l20.beginPath();
	l20.arc(mpxo, biy, blr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	l20.strokePath();

	circuitLines.strokeLineShape(l22);
	circuitLines.strokeLineShape(l23);
	circuitLines.strokeLineShape(l24);

	const l25 = context.add.graphics();
	l25.lineStyle(1, 0x000000, 1);
	l25.beginPath();
	l25.arc(mpx, b1ty, bsr, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(180), true);
	l25.strokePath();

	circuitLines.strokeLineShape(l26);

	//top of positive line for cell
	const cellposty = toy + (ww/2) - (celllh/2);
	//bottom of positive line for cell
	const cellposby = cellposty + celllh;

	//top of negative thick line for cell
	const cellnegty = toy + (ww/2) - (cellrh/2);
	//bottom of negative thick line for cell
	const cellnegby = cellnegty + cellrh;

	//draw the left hand positive (thin) cell line
	const cellpos = new Phaser.Geom.Line(clx, cellposty, clx, cellposby);
	circuitLines.strokeLineShape(cellpos);

	//draw the right hand negative (thick) cell line - it needs a different style
	const negCellLine = context.add.graphics({ lineStyle: { width: 5, color: 0x000000 } });
	const cellneg = new Phaser.Geom.Line(crx, cellnegty, crx, cellnegby);
	negCellLine.strokeLineShape(cellneg);

	//draw the two globes around the filaments
	const globe1 = new Phaser.Geom.Circle(mpx, b1ty, gr);
	const globe2 = new Phaser.Geom.Circle(mpxo, biy, gr);
	const globe3 = new Phaser.Geom.Circle(centero, biy, gr);

	const globeGraphics = context.add.graphics({ lineStyle: { width: 1, color: 0x000000 } });

	globeGraphics.strokeCircleShape(globe1);
	globeGraphics.strokeCircleShape(globe2);
	globeGraphics.strokeCircleShape(globe3);

	//create some global variables to be used in the mapping function - all values are for the middle of the wire
	//see https://docs.google.com/presentation/d/1iP_TTmhVB4uu238Fdf6szaIlPHxZ-5snqz01gnPP5Do/edit?usp=sharing

	hw = ww/2;
	_g.mty = toy + hw;
	_g.mlx = lox + hw;
	_g.mlxo = _g.mlx;
	_g.mby = biy + hw;
	_g.mrx = rix + hw;
	_g.mrxo = _g.mrx + bulb2offset;
	_g.mr = bsr + hw;
	_g.mblx = bsrlx - hw;
	_g.mblxo = _g.mblx + bulb2offset;
	_g.mbrx = bsrrx + hw;
	_g.mbrxo = _g.mbrx + bulb2offset;

	_g.mpx = mpx;
	_g.mpxo = mpxo;
	_g.mpy = mpy;

	_g.clx = clx;
	_g.crx = crx;

	_g.biy = biy;

	_g.ww = ww;

	_g.rox = rox;
	_g.lox = lox;

	_g.blr = blr;
	_g.bsr = bsr;

	_g.blrlx = blrlx;
	_g.blrlxo = blrlxo;
	_g.blrlxo2 = bsrrxo2 + ww;
	_g.bsrlx = bsrlx;
	_g.bsrlxo = bsrlxo;
	_g.bsrlxo2 = bsrlxo2;

	_g.blrrx = blrrx;
	_g.bsrrx = bsrrx;
	_g.blrrxo = blrrxo;
	_g.bsrrxo2 = bsrrxo2;

	_g.b1ty = b1ty;
	_g.b1by = b1by;

	_g.toy = toy;
	_g.tiy = tiy;

	_g.lix = lix;
	_g.boy = boy;

	_g.rix = rix;

	_g.hw = hw;

	_g.bulb1Topy = _g.b1ty - _g.blr;
	_g.bulb2Topy = _g.biy - _g.blr;

	_g.centero = centero;
	_g.lampspace = lampspace;
	_g.outerpoint = bsrrxo2 + ww;

}

//This is a dev function to help with placement
function createGrid(context) {
	gridLines = context.add.graphics({ lineStyle: { width: 0.2, color: 0xafeeee } });

	const interval = 50;
	let currentLine = 0;
	let line = [];
	let axisValue = [];

	//vertical lines
	for (let xGrid =  0; xGrid < _g.width; xGrid += interval) {
		 line[currentLine] = new Phaser.Geom.Line(xGrid, 10, xGrid, _g.height);
		 gridLines.strokeLineShape(line[currentLine]);

		 axisValue[currentLine] = context.add.text(xGrid-10, 0, xGrid, { fontSize: '15px', fill: '#000000' });

		 currentLine++;
	}

	//horizontal lines
	for (let yGrid =  0; yGrid < _g.height; yGrid += interval) {
		 line[currentLine] = new Phaser.Geom.Line(30, yGrid, _g.width, yGrid);
		 gridLines.strokeLineShape(line[currentLine]);

		 axisValue[currentLine] = context.add.text(0, yGrid-7, yGrid, { fontSize: '15px', fill: '#000000' });

		 currentLine++;
	}
}

const _g = {
	xoffset: 45, // for another bulb
	width: 1000,
	height: 550
};

const config = {
	type: Phaser.AUTO,
	width: _g.width+_g.xoffset,
	height: _g.height,
	backgroundColor: "f9f9f9",
	physics: {
	default: 'arcade',
	arcade: {
		gravity: { y: 0 },
		enableBody: true,
		}
	},
	scene: {
	    preload: preload,
	    create: create,
	    update: update
	}
};

const game = new Phaser.Game(config);
</script></head><body style="overflow: hidden;"></body></html>
